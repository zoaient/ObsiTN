/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/obsidian-excalidraw-plugin/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-excalidraw-plugin/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var getEA2 = (view) => {
      try {
        return window.ExcalidrawAutomate.getAPI(view);
      } catch (e) {
        console.log({ message: "Excalidraw not available", fn: getEA2 });
        return null;
      }
    };
    exports.getEA = getEA2;
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module2) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size3 = data.size;
          data.set(key, value);
          this.size += data.size == size3 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity2 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size3 = data.size;
            switch (data.type) {
              case "drop":
                start += size3;
                break;
              case "dropRight":
                end -= size3;
                break;
              case "take":
                end = nativeMin(end, start + size3);
                break;
              case "takeRight":
                start = nativeMax(start, end - size3);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size3) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size3 = size3 === undefined2 ? length : size3;
          while (++index < size3) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size3;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size3, guard) {
          if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined2) {
            size3 = 1;
          } else {
            size3 = nativeMax(toInteger(size3), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size3 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size3);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take2(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith2(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size2(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now3 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight2(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight2.placeholder;
          return result2;
        }
        function debounce3(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now3();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush2() {
            return timerId === undefined2 ? result2 : trailingEdge(now3());
          }
          function debounced() {
            var time = now3(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush2;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle2(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce3(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight2;
        lodash.debounce = debounce3;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take2;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle2;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith2;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update2;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity2;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop2;
        lodash.now = now3;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size2;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CardNote
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");

// src/dragUpdate.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");

// src/utility.ts
var BLOCKIDREPLACE = () => /[^a-zA-Z\d-]+/g;
var FILENAMEREPLACE = () => /[!"#$%&()*+,.:;<=>?@^`{|}~/[\]\\\r\n]/g;
var HEADINGREPLACE = () => /([:#|^\\\r\n]|%%|\[\[|]])/g;
var getCacheOffset = (c) => {
  const cacheStart = c.position.start.offset, cacheEnd = c.position.end.offset;
  return [cacheStart, cacheEnd];
};
function throttle(cb, secondTimeout = 0) {
  let timer = false;
  let result;
  return (...args) => {
    if (!timer) {
      timer = true;
      setTimeout(() => {
        timer = false;
      }, 1e3 * secondTimeout);
      result = cb(...args);
    }
    return result;
  };
}
var LineBreak = "\n";
var MarkdownFileExtension = ".md";
function isBreak(name) {
  return name === void 0;
}
function createFullPath(file) {
  const fileName = `${file.fileName}${file.extension}`;
  return file.folderPath.length === 0 ? fileName : `${file.folderPath}/${fileName}`;
}
async function ReCheck(config) {
  let errorMessage;
  let args = config.create();
  let result;
  while (true) {
    try {
      result = await config.provide(args, result, errorMessage);
      if (isBreak(result)) {
        return result;
      }
      const validResult = await config.check(result);
      if (validResult instanceof Error) {
        throw validResult;
      } else {
        return validResult;
      }
    } catch (error) {
      args = config.update(args);
      errorMessage = error.message;
      continue;
    }
  }
}
var LIST = /^([ \t]*)(?<listSymbol>[*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))(?<item>[^\n]*)/;
var TASK = /^([ \t]*)(?<task>\[.\])?( {1,4}(?! )| |\t|$|(?=\n))(?<item>[^\n]*)/;
function listItemParser(text2) {
  const match = LIST.exec(text2);
  if (match) {
    const groups = match.groups, listSymbol = groups == null ? void 0 : groups.listSymbol, item = groups == null ? void 0 : groups.item;
    if (item) {
      const taskMatch = TASK.exec(item), taskGroups = taskMatch == null ? void 0 : taskMatch.groups, task = taskGroups == null ? void 0 : taskGroups.task, taskItem = taskGroups == null ? void 0 : taskGroups.item;
      return task ? {
        type: "task",
        listSymbol,
        task,
        item: taskItem != null ? taskItem : ""
      } : {
        type: "list",
        listSymbol,
        item
      };
    } else {
      return {
        type: "list",
        listSymbol,
        item: ""
      };
    }
  }
}
var WIKILINK = () => new RegExp(/^(?<left>!?\[\[)(?<link>.*?)(?<display>\|(?<displayText>.*))?(?<right>]])$/);
var MARKDOWNLINK = () => /^(?<left>!?\[)(?<displayText>.*?)(?<mid>]\(\s*)(?<link>[^ ]+)(?<right>(?:\s+.*?)?\))$/;
function UpdateLinkText(sourcePath, linkInfo, newPath) {
  const linkMatch = [
    {
      regex: WIKILINK(),
      newText: (match, path) => {
        var _a, _b, _c, _d;
        const display = (_b = (_a = match.groups) == null ? void 0 : _a.display) != null ? _b : "";
        return `${(_c = match.groups) == null ? void 0 : _c.left}${path}${display}${(_d = match.groups) == null ? void 0 : _d.right}`;
      }
    },
    {
      regex: MARKDOWNLINK(),
      newText(match, path) {
        var _a, _b, _c, _d, _e;
        const display = (_b = (_a = match.groups) == null ? void 0 : _a.displayText) != null ? _b : "";
        return `${(_c = match.groups) == null ? void 0 : _c.left}${display}${(_d = match.groups) == null ? void 0 : _d.mid}${path}${(_e = match.groups) == null ? void 0 : _e.right}`;
      }
    }
  ];
  for (const r of linkMatch) {
    const match = r.regex.exec(linkInfo.link.original);
    if (match) {
      const np = newPath(linkInfo);
      const newText = r.newText(match, np);
      return {
        change: newText,
        reference: linkInfo.link,
        sourcePath
      };
    }
  }
  return {
    change: `[[${newPath(linkInfo)}]]`,
    reference: linkInfo.link,
    sourcePath
  };
}
function LinkToChanges(linkMap, newPath) {
  const change = {
    data: {},
    keys: () => Object.keys(change.data),
    add: (key, value) => {
      const values = change.data[key];
      if (values && !values.contains(value)) {
        if (!values.contains(value)) {
          values.push(value);
        }
      } else {
        change.data[key] = [value];
      }
    },
    remove: (key, value) => {
      const values = change.data[key];
      values == null ? void 0 : values.remove(value);
    },
    removeKey: (key) => {
      delete change.data[key];
    },
    get: (key) => change.data[key],
    clear: (key) => change.removeKey(key),
    clearAll: () => {
      change.data = {};
    },
    contains: (key, value) => {
      var _a;
      return (_a = change.data[key]) == null ? void 0 : _a.contains(value);
    },
    count: () => {
      let c = 0;
      for (const key in change.data) {
        const len = change.data[key].length;
        c += len;
      }
      return c;
    }
  };
  linkMap.forEach((value, key) => {
    const changeInfo = value.map((text2) => UpdateLinkText(key, text2, newPath));
    change.data[key] = changeInfo;
  });
  return change;
}
var reverseRelative = /* @__PURE__ */ new Map([
  ["top", "bottom"],
  ["right", "left"],
  ["bottom", "top"],
  ["left", "right"]
]);
function getRelativePosition(center, relative) {
  const { x: xStart, y: yStart, width, height } = center;
  const xEnd = xStart + width, yEnd = yStart + height;
  const { x: xR, y: yR, width: Rwidth } = relative;
  const xREnd = xR + Rwidth;
  return xR >= xEnd ? "right" : xREnd <= xStart ? "left" : yR <= yStart ? "top" : yR >= yEnd ? "bottom" : void 0;
}
function tryCreateRegex(pattern, flags) {
  try {
    return new RegExp(pattern, flags);
  } catch (e) {
  }
}

// src/dragUpdate.ts
var import_obsidian3 = require("obsidian");

// src/ui.ts
var import_obsidian = require("obsidian");
var FileNameCheckModal = class extends import_obsidian.Modal {
  constructor(config) {
    super(config.plugin.app);
    this.getNameDesc = (fileName, blockName) => {
      const frag = document.createDocumentFragment();
      frag.createDiv().innerText = `Create file ${fileName}`;
      if (blockName) {
        frag.createDiv().innerText = `or`;
        frag.createDiv().innerText = `Link to block ${fileName}`;
      }
      return frag;
    };
    this.plugin = config.plugin;
    this.userInput = config.name;
    this.section = config.section;
    this.onSubmit = config.onSubmit;
    this.errorMessage = config.errorMessage;
  }
  onOpen() {
    const linkReferenceDescription = this.section.type === "reference" ? isHeadingBlock(this.section.block) ? " or link to heading" : " or link to block" : "";
    const { contentEl } = this;
    let userInputText;
    const nameSetting = new import_obsidian.Setting(contentEl).setDesc(`Create file${linkReferenceDescription}`).addText((text2) => {
      var _a;
      userInputText = text2;
      text2.setValue((_a = this.userInput) != null ? _a : "");
      text2.onChange((value) => {
        this.userInput = value;
      });
    }).addButton((btn) => {
      btn.setIcon("dices").setTooltip("Create random block id").setCta().onClick(() => {
        this.userInput = this.plugin.createRandomHexString();
        userInputText == null ? void 0 : userInputText.setValue(this.userInput);
      });
    });
    const actions = new import_obsidian.Setting(contentEl).addButton((btn) => {
      btn.setIcon("file-plus-2").setTooltip("Create file").setCta().onClick(() => {
        this.onSubmit({ type: "createFile", newName: this.userInput.trimEnd() });
        this.close();
      });
    });
    if (this.section.type === "reference") {
      const section = this.section;
      actions.addButton((btn) => {
        btn.setIcon("link").setTooltip("Link to reference").setCta().onClick(() => {
          this.onSubmit({
            type: "linkToReference",
            section,
            newName: this.userInput.trimEnd()
          });
          this.close();
        });
      });
    }
    actions.addButton((btn) => {
      btn.setIcon("scissors").setTooltip("Cut").setCta().onClick(() => {
        this.onSubmit({ type: "cut" });
        this.close();
      });
    }).addButton((btn) => {
      btn.setIcon("x").setTooltip(`Cancel`).setCta().onClick(() => {
        this.onSubmit({ type: "cancel" });
        this.close();
      });
    });
    if (this.errorMessage) {
      actions.setDesc(this.errorMessage);
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  trySetDescription(setting, desc) {
    try {
      setting == null ? void 0 : setting.setDesc(desc);
    } catch (e) {
      console.log("expect set description before closing Modal", e);
    }
  }
  debounce(fn, sec) {
    let timer;
    return (...arg) => {
      clearTimeout(timer);
      return new Promise((resolve) => {
        timer = setTimeout(() => {
          const res = fn(...arg);
          resolve(res);
        }, sec * 1e3);
      });
    };
  }
  parseToValidFile(text2) {
    return text2.replace(FILENAMEREPLACE(), "");
  }
  parseToValidBlockName(text2) {
    if (this.section.type === "reference") {
      const block = this.section.block;
      return isHeadingBlock(block) ? text2 : text2.replace(BLOCKIDREPLACE(), "");
    }
  }
};

// src/adapters/obsidian-excalidraw-plugin/index.ts
var import_obsidian2 = require("obsidian");
var import_obsidian_excalidraw_plugin = __toESM(require_lib());
var VIEW_TYPE_EXCALIDRAW = "excalidraw";
function getEA(view) {
  return (0, import_obsidian_excalidraw_plugin.getEA)(view);
}
function isExcalidrawView(view) {
  return view.getViewType() === VIEW_TYPE_EXCALIDRAW;
}
var MAX_IMAGE_SIZE = 500;
async function insertEmbeddableOnDrawing(event, view, fileLink, file, plugin) {
  try {
    const ea = getEA();
    const eaView = ea.setView(view);
    const pos = ExcalidrawLib.viewportCoordsToSceneCoords({
      clientX: event.clientX,
      clientY: event.clientY
    }, eaView.excalidrawAPI.getAppState());
    const id = ea.addEmbeddable(
      pos.x,
      pos.y,
      MAX_IMAGE_SIZE,
      MAX_IMAGE_SIZE,
      fileLink,
      file
    );
    await ea.addElementsToView(false, true, true);
    ea.selectElementsInView([id]);
    return id;
  } catch (error) {
    console.log(error);
  }
}
async function createTextOnDrawing(event, view, text2, plugin) {
  var _a, _b, _c, _d, _e;
  try {
    const ea = getEA();
    const eaView = ea.setView(view);
    const appState = view.excalidrawAPI.getAppState();
    ea.style.strokeColor = (_a = appState.currentItemStrokeColor) != null ? _a : "black";
    ea.style.opacity = (_b = appState.currentItemOpacity) != null ? _b : 1;
    ea.style.fontFamily = (_c = appState.currentItemFontFamily) != null ? _c : 1;
    ea.style.fontSize = (_d = appState.currentItemFontSize) != null ? _d : 20;
    ea.style.textAlign = (_e = appState.currentItemTextAlign) != null ? _e : "left";
    const pos = ExcalidrawLib.viewportCoordsToSceneCoords({
      clientX: event.clientX,
      clientY: event.clientY
    }, eaView.excalidrawAPI.getAppState());
    const id = ea.addText(
      pos.x,
      pos.y,
      text2
    );
    await view.addElements(ea.getElements(), false, true, void 0, true);
    return id;
  } catch (error) {
    console.log(error);
  }
}
async function addLink(fromNodeId, toNodeId, view, plugin) {
  try {
    const ea = getEA();
    const eaView = ea.setView(view);
    ea.copyViewElementsToEAforEditing(ea.getViewElements());
    const edgeId = ea.connectObjects(fromNodeId, null, toNodeId, null, {
      startArrowHead: plugin.arrowToFrom() ? "arrow" : null,
      endArrowHead: plugin.arrowToEnd() ? "arrow" : null
    });
    const label = plugin.settings.defaultLinkLabel;
    if (label) {
      const labelId = ea.addLabelToLine(edgeId, label);
      const edge = ea.elementsDict[edgeId];
      edge.boundElements.push(
        {
          type: "text",
          id: labelId
        }
      );
      const labelElement = ea.elementsDict[labelId];
      labelElement.containerId = edgeId;
      labelElement.angle = 0;
    }
    await ea.addElementsToView(false, true, true);
  } catch (error) {
    console.log(error);
  }
}

// src/adapters/obsidian/index.ts
var OBSIDIAN_CANVAS = "canvas";
function isObsidianCanvasView(view) {
  return (view == null ? void 0 : view.getViewType()) === OBSIDIAN_CANVAS;
}
function isCanvasFileNode(node) {
  return "file" in node && "canvas" in node;
}
function isCanvasEditorNode(node) {
  return node ? ("file" in node || "text" in node) && "id" in node : false;
}
function getOffset(node) {
  const child = isCanvasFileNode(node) ? node.child : void 0;
  return child === void 0 ? 0 : (child == null ? void 0 : child.before.length) + (child == null ? void 0 : child.heading.length);
}

// src/dragUpdate.ts
function isNamedBlock(block) {
  return "name" in block && block.name !== void 0;
}
function isHeadingBlock(block) {
  return "type" in block && block.type === "heading";
}
function isListBlock(block) {
  return "type" in block && block.type === "list";
}
function getSelectOffset(select) {
  var _a;
  if (select.type === "line" && ((_a = select.section) == null ? void 0 : _a.type) === "reference") {
    const pos = select.section.block.cache.position;
    return {
      from: pos.start.offset - select.textOffset,
      to: pos.end.offset - select.textOffset
    };
  } else {
    return {
      from: select.selection.from,
      to: select.selection.to
    };
  }
}
function getLinkBlocks(select, file, plugin) {
  const textOffset = select.textOffset;
  if (!file) {
    return [[], []];
  } else if (select.type === "mutiple") {
    const res = select.selections.map((sel) => plugin.findLinkBlocks(file, sel.from + textOffset, sel.to + textOffset));
    const blocks = res.flatMap((r) => r[0]);
    const headings = res.flatMap((r) => r[1]);
    return [blocks, headings];
  } else {
    const { from, to } = getSelectOffset(select);
    return plugin.findLinkBlocks(file, from + textOffset, to + textOffset);
  }
}
async function userAction(plugin, section, selected) {
  const folderPath = plugin.settings.defaultFolder;
  const getUserRename = (config) => {
    return new Promise((resolve) => {
      const onSubmit = (action2) => {
        resolve({ ...action2 });
      };
      new FileNameCheckModal({ ...config, onSubmit }).open();
    });
  };
  const provide = async (arg, unvalid, error) => {
    if ((unvalid == null ? void 0 : unvalid.type) !== "cancel" && (unvalid == null ? void 0 : unvalid.type) !== "cut") {
      const newName = unvalid == null ? void 0 : unvalid.newName;
      const name = newName && newName.length !== 0 ? newName : arg.name;
      return getUserRename({ ...arg, name, errorMessage: error });
    }
  };
  const check = async (value) => {
    if (value.type !== "cancel" && value.type !== "cut") {
      const newName = value.newName;
      if (value.type === "createFile") {
        const file = await plugin.checkFileName({ folderPath, fileName: newName, extension: MarkdownFileExtension });
        return file instanceof Error ? file : { ...value, file };
      }
      if (value.type === "linkToReference") {
        const findUnvalidBlockSymbol = () => BLOCKIDREPLACE().exec(value.newName);
        return isHeadingBlock(value.section.block) ? value : findUnvalidBlockSymbol() ? new Error("Block id only accept alphanumeric and -") : value;
      }
    }
    return value;
  };
  const action = await ReCheck({
    create() {
      var _a;
      const getDefault = () => {
        return selected.content.split(LineBreak, 1)[0].substring(0, 20).trim();
      };
      const defulatName = section.type === "reference" ? isNamedBlock(section.block) ? section.block.name : isListBlock(section.block) ? (_a = listItemParser(selected.content)) == null ? void 0 : _a.item : getDefault() : getDefault();
      return {
        plugin,
        section,
        name: defulatName != null ? defulatName : ""
      };
    },
    update(prev) {
      return prev;
    },
    provide,
    check
  });
  return action;
}
function getSection(source, selected, plugin) {
  var _a, _b, _c;
  const sourceFile = getFile(source);
  if (sourceFile instanceof import_obsidian3.TFile && selected.type !== "mutiple") {
    const offset = (_a = source == null ? void 0 : source.offset) != null ? _a : 0;
    const fileCache = plugin.app.metadataCache.getFileCache(sourceFile), matchStart = (block2) => {
      const start = selected.selection.from + offset;
      return block2.position.start.offset === start;
    }, touch = (block2) => {
      const start = selected.selection.from + offset, end = selected.selection.to + offset, blockStart = block2.position.start.offset, blockEnd = block2.position.end.offset;
      return blockEnd > start && blockEnd <= end || blockStart >= start && blockStart < end;
    }, findCorrespondBlock = () => {
      var _a2;
      const start = selected.selection.from + offset;
      const block2 = (_a2 = fileCache == null ? void 0 : fileCache.sections) == null ? void 0 : _a2.find((cache) => {
        if (cache.type === "list") {
          return cache.position.start.offset <= start && start <= cache.position.end.offset;
        } else {
          return matchStart(cache);
        }
      });
      return block2;
    };
    const blockCache = findCorrespondBlock(), getList = () => {
      var _a2;
      const listItem = (_a2 = fileCache == null ? void 0 : fileCache.listItems) == null ? void 0 : _a2.find((item) => {
        const listStartPosition = item.position.start, listEndPosition = item.position.end, listStart = listStartPosition.offset, listEnd = listEndPosition.offset, listLineStart = listStart - listStartPosition.col, selectStart = selected.selection.from + offset, selectEnd = selected.selection.to + offset;
        return selectStart >= listLineStart && (listStart >= selectStart && listEnd <= selectEnd);
      });
      if (listItem) {
        return {
          type: "list",
          cache: listItem,
          name: listItem.id
        };
      }
    }, getHeading = () => {
      var _a2;
      const heading = (_a2 = fileCache == null ? void 0 : fileCache.headings) == null ? void 0 : _a2.find(matchStart);
      if (heading) {
        return {
          type: "heading",
          name: heading == null ? void 0 : heading.heading,
          cache: heading
        };
      }
    }, getBlock = () => {
      if (blockCache) {
        if (blockCache.type === "list") {
          return getList();
        } else if (blockCache.type === "heading") {
          return getHeading();
        } else {
          return blockCache.id ? {
            type: "linkBlock",
            cache: blockCache,
            name: blockCache.id
          } : {
            cache: blockCache
          };
        }
      }
    };
    const block = (_c = (_b = getList()) != null ? _b : getHeading()) != null ? _c : getBlock();
    return block ? {
      type: "reference",
      block,
      file: sourceFile
    } : {
      type: "unreference"
    };
  } else {
    return {
      type: "unreference"
    };
  }
}
function fileUpdateObserver(plugin, file) {
  let res, waiting = [];
  const metadataCache = plugin.app.metadataCache;
  const e = metadataCache.on("changed", (changeFile, data, cache) => {
    if (changeFile === file) {
      const r = {
        file: changeFile,
        data,
        cache
      };
      res = Promise.resolve(r);
      waiting.forEach((resolve) => resolve(r));
      waiting = [];
    }
  });
  return {
    getUpdate: () => res != null ? res : new Promise((resolve) => {
      waiting.push(resolve);
    }),
    close: () => metadataCache.offref(e)
  };
}
async function onFilesUpdated(plugin, files, on, timeLimited) {
  const time = timeLimited * files.length, observers = files.map((file) => fileUpdateObserver(plugin, file)), closeObserver = () => observers.forEach((ob) => ob.close()), update2 = observers.map((ob) => ob.getUpdate());
  return new Promise((resolve, reject) => {
    resolve(Promise.all(update2).then((data) => {
      closeObserver();
      on(data);
    }));
    setTimeout(() => {
      closeObserver();
      reject(`files: ${files.map((file) => file.path)} are not detected in ${time} seconds, `);
    }, 1e3 * time);
  });
}
function getFile(ed) {
  const hasFile = (fe) => {
    return "file" in fe;
  };
  if ((ed == null ? void 0 : ed.fileEditor) && hasFile(ed.fileEditor)) {
    return ed.fileEditor.file;
  }
}
async function extractSelect(action, extract, view, activeFile, whiteboard, plugin) {
  const updateInternalLinks = async (sourceFile, createNewPath, match, updateAfterDraw) => {
    var _a;
    const linksInFiles = plugin.findLinks(sourceFile, match);
    onFilesUpdated(plugin, updateAfterDraw, async (data) => {
      const [selfLinks, _2] = await linksInFiles;
      if (selfLinks) {
        const linksSet = selfLinks.map((l) => l.link.link);
        const res = /* @__PURE__ */ new Map();
        data.map((d) => {
          var _a2, _b;
          const links = (_a2 = d.cache.links) != null ? _a2 : [];
          const embeds = (_b = d.cache.embeds) != null ? _b : [];
          const all = links.concat(embeds);
          const linkRef = all.filter((cache) => linksSet.contains(cache.link)).map(plugin.createLinkInfo);
          return {
            file: d.file.path,
            linkRef
          };
        }).forEach((d) => {
          if (d.linkRef.length > 0) {
            res.set(d.file, d.linkRef);
          }
        });
        plugin.updateInternalLinks(res, (text2) => {
          const newPath = createNewPath({ path: text2.path, subpath: text2.subpath });
          return `${newPath.path}${newPath.subpath}`;
        });
      }
    }, 10);
    const [_, outer] = await linksInFiles;
    const canvasHasMatchLinks = plugin.getCanvas((canvasPath, embed) => {
      var _a2;
      const subpath = embed.subpath;
      return match({ path: (_a2 = embed.file) != null ? _a2 : "", subpath });
    });
    const whiteboardPath = (_a = whiteboard.located.file) == null ? void 0 : _a.path, updateLinksInDraw = () => {
      whiteboard.updateLinks({
        getNewPath: createNewPath,
        linkMatch: match
      });
    };
    if (outer.has(whiteboardPath != null ? whiteboardPath : "")) {
      outer.delete(whiteboardPath != null ? whiteboardPath : "");
      updateLinksInDraw();
    } else if (canvasHasMatchLinks.contains(whiteboardPath != null ? whiteboardPath : "")) {
      canvasHasMatchLinks.remove(whiteboardPath != null ? whiteboardPath : "");
      updateLinksInDraw();
    }
    plugin.updateInternalLinks(outer, (text2) => {
      const newPath = createNewPath({ path: text2.path, subpath: text2.subpath });
      return `${newPath.path}${newPath.subpath}`;
    });
    plugin.updateCanvasLinks(canvasHasMatchLinks, (node) => {
      if (match({ path: node.file, subpath: node.subpath })) {
        const newPath = createNewPath({ path: node.file, subpath: node.subpath });
        return {
          ...node,
          file: newPath.path + MarkdownFileExtension,
          subpath: newPath.subpath
        };
      }
      return node;
    });
  };
  if (action.type === "createFile") {
    const updateConfig = () => {
      const sourceFile = getFile(activeFile);
      if (sourceFile) {
        const match = (link) => (link.path === sourceFile.path || link.file === sourceFile) && link.subpath !== void 0 && subpathSet.contains(link.subpath);
        const createNewPath = (oldPath) => {
          return plugin.createLinkText(newFile, oldPath.subpath, oldPath.displayText);
        };
        const [blocks, headings] = getLinkBlocks(extract, sourceFile, plugin);
        const subpathSet = [...blocks.map((block) => `#^${block.id}`), ...headings.map((cache) => `#${plugin.normalizeHeadingToLinkText(cache.heading)}`)];
        return {
          sourceFile,
          match,
          createNewPath,
          subpathSet
        };
      }
    };
    const config = updateConfig();
    const filePath = action.file.fileName;
    const newFile = await plugin.app.vault.create(filePath, extract.content);
    const newFileLink = plugin.createLinkText(newFile);
    const replaceTextWithLink = () => {
      const trans = view.state.update({
        changes: extract.type !== "mutiple" ? { ...getSelectOffset(extract), insert: newFileLink.text } : extract.selections.map((line) => {
          return { from: line.from, to: line.to, insert: newFileLink.text };
        })
      });
      view.dispatch(trans);
    };
    replaceTextWithLink();
    if (config && config.subpathSet.length !== 0) {
      const { sourceFile, createNewPath, match } = config;
      await updateInternalLinks(sourceFile, createNewPath, match, [sourceFile, newFile]);
    }
    whiteboard.draw(newFileLink);
  } else if (action.type === "linkToReference") {
    const block = action.section.block, sourceFile = action.section.file;
    const name = action.newName;
    const subpath = isHeadingBlock(block) ? {
      symbol: "#",
      path: plugin.normalizeHeadingToLinkText(name)
    } : {
      symbol: "#^",
      path: name
    };
    const oldBlock = isNamedBlock(block) ? block : void 0;
    const newPath = plugin.createLinkText(sourceFile, subpath.symbol + subpath.path);
    if (oldBlock) {
      const reName = () => oldBlock.name !== name;
      if (reName()) {
        const oldName = oldBlock.name, oldPath = isHeadingBlock(oldBlock) ? "#" + plugin.normalizeHeadingToLinkText(oldName) : "#^" + oldName, from = block.cache.position.end.offset - extract.textOffset - oldName.length, to = block.cache.position.end.offset - extract.textOffset;
        const trans = view.state.update({
          changes: { from, to, insert: subpath.path }
        });
        view.dispatch(trans);
        await updateInternalLinks(
          sourceFile,
          (old) => newPath,
          (link) => (link.path === sourceFile.path || link.file === sourceFile) && link.subpath !== void 0 && link.subpath === oldPath,
          [sourceFile]
        );
      }
    } else {
      const insertNamePosition = block.cache.position.end.offset - extract.textOffset;
      const trans = view.state.update({
        changes: { from: insertNamePosition, insert: " ^" + name }
      });
      view.dispatch(trans);
    }
    whiteboard.draw(newPath);
  } else {
    const deleteText = () => {
      const trans = view.state.update({
        changes: extract.type !== "mutiple" ? { ...getSelectOffset(extract) } : extract.selections.map((line) => {
          return { from: line.from, to: line.to };
        })
      });
      view.dispatch(trans);
    };
    deleteText();
    whiteboard.draw(extract.content);
  }
}
var dragExtension = (plugin) => {
  const addDragStartEvent = (dragSymbol, view) => {
    let info;
    let source;
    let listener;
    const handleDrop = async (e) => {
      const createFileAndDraw = async (whiteboard) => {
        var _a;
        const section = info.type === "line" && info.section ? info.section : getSection(source, info, plugin);
        const action = await userAction(plugin, section, info);
        if (!isBreak(action) && action.type !== "cancel") {
          extractSelect(
            action,
            { ...info, textOffset: (_a = source == null ? void 0 : source.offset) != null ? _a : 0 },
            view,
            source,
            whiteboard,
            plugin
          );
        }
      };
      const drawView = plugin.getDropView(e);
      if (isExcalidrawView(drawView)) {
        createFileAndDraw(
          {
            located: drawView,
            draw: async (target) => {
              const createNode = typeof target === "string" ? createTextOnDrawing(e, drawView, target, plugin) : insertEmbeddableOnDrawing(e, drawView, target.text, target.file, plugin);
              if (plugin.settings.autoLink && isCanvasEditorNode(source == null ? void 0 : source.fileEditor)) {
                const createNodeId = await createNode;
                if (createNodeId) {
                  await addLink(source.fileEditor.id, createNodeId, drawView, plugin);
                }
              }
            },
            updateLinks: (para) => {
              const { linkMatch, getNewPath } = para;
              const nodes = Array.from(drawView.canvasNodeFactory.nodes.entries()).map((value) => {
                const [id, refNode] = value;
                const getLinkInfo = (node) => {
                  return { path: node.filePath, subpath: node.subpath };
                };
                if (isCanvasFileNode(refNode) && linkMatch(getLinkInfo(refNode))) {
                  return { id, link: getNewPath(getLinkInfo(refNode)) };
                }
              }).filter((v) => v !== void 0);
              nodes.forEach(
                (node) => {
                  const elements = drawView.excalidrawAPI.getSceneElements().filter((e2) => e2.id === node.id);
                  elements.forEach((elem) => {
                    drawView.excalidrawData.elementLinks.set(node.id, node.link.text);
                    ExcalidrawLib.mutateElement(elem, { link: node.link.text });
                  });
                }
              );
              drawView.setDirty(99);
              drawView.updateScene({});
            }
          }
        );
      } else if (isObsidianCanvasView(drawView)) {
        const pos = drawView.canvas.posFromEvt(e);
        createFileAndDraw({
          located: drawView,
          draw: async (target) => {
            const dropCanvas = drawView.canvas;
            const createNode = typeof target === "string" ? dropCanvas.createTextNode({
              text: target,
              pos,
              save: false
            }) : dropCanvas.createFileNode({
              file: target.file,
              pos,
              subpath: target.subpath,
              save: false
            });
            if (plugin.settings.autoLink && isCanvasEditorNode(source == null ? void 0 : source.fileEditor)) {
              const fromSide = getRelativePosition(source.fileEditor, createNode);
              if (fromSide && reverseRelative.has(fromSide)) {
                const toSide = reverseRelative.get(fromSide);
                const edgeID = plugin.createRandomHexString(16);
                const fromEnd = plugin.arrowToFrom() ? "arrow" : "none";
                const toEnd = plugin.arrowToEnd() ? "arrow" : "none";
                const label = plugin.settings.defaultLinkLabel;
                const edgeSample = dropCanvas.edges.values().next().value;
                if (edgeSample) {
                  const e2 = new edgeSample.constructor(
                    dropCanvas,
                    edgeID,
                    { side: fromSide, node: source.fileEditor, end: fromEnd },
                    { side: toSide, node: createNode, end: toEnd }
                  );
                  e2.setLabel(label);
                  dropCanvas.addEdge(e2);
                  e2.attach();
                  e2.render();
                } else {
                  const data = dropCanvas.getData();
                  dropCanvas.importData({
                    nodes: data.nodes,
                    edges: [...data.edges, {
                      id: edgeID,
                      fromNode: source.fileEditor.id,
                      fromSide,
                      fromEnd,
                      toNode: createNode.id,
                      toSide,
                      toEnd,
                      label
                    }]
                  });
                }
              }
            } else {
              await dropCanvas.requestFrame();
            }
            dropCanvas.requestSave();
          },
          updateLinks: (para) => {
            const { linkMatch, getNewPath } = para;
            drawView.canvas.nodes.forEach((node, id) => {
              var _a;
              const path = (node2) => ({
                path: node2.filePath,
                file: node2.file,
                subpath: node2.subpath
              });
              if (isCanvasFileNode(node) && linkMatch(path(node))) {
                const newPath = getNewPath(path(node));
                node.setFilePath(newPath.file.path, (_a = newPath.subpath) != null ? _a : "");
              }
            });
            drawView.canvas.requestSave();
          }
        });
      }
    };
    dragSymbol.addEventListener("dragstart", (e) => {
      source = plugin.getActiveEditorFile();
      const getSelection = () => {
        const selectLines = view.state.selection.ranges.map((range) => ({
          from: range.from,
          to: range.to
        }));
        const content = selectLines.map((range) => {
          return view.state.sliceDoc(range.from, range.to);
        }).join().trim();
        return { content, selectLines };
      };
      const getLineString = () => {
        var _a;
        const statefield = view.state.field(dragSymbolSet);
        const start = statefield.iter().from;
        const doc = view.state.doc;
        const line = view.state.doc.lineAt(start);
        const foldableRange = (0, import_language.foldable)(view.state, line.from, line.to);
        if (foldableRange) {
          return {
            type: "foldable",
            startLine: line,
            selection: {
              from: line.from,
              to: foldableRange.to
            },
            content: doc.sliceString(line.from, foldableRange.to)
          };
        } else {
          const selected = {
            type: "line",
            line,
            selection: {
              from: line.from,
              to: line.to
            }
          };
          const referenceTextOffset = (_a = source == null ? void 0 : source.offset) != null ? _a : 0;
          const section = getSection(source, { ...selected, content: "" }, plugin);
          const content = section && section.type === "reference" ? doc.sliceString(
            section.block.cache.position.start.offset - referenceTextOffset,
            section.block.cache.position.end.offset - referenceTextOffset
          ) : line.text;
          return {
            ...selected,
            content,
            section
          };
        }
      };
      const defaultSelect = getSelection();
      info = defaultSelect.content.length === 0 ? getLineString() : defaultSelect.selectLines.length === 1 ? { type: "single", selection: defaultSelect.selectLines.first(), content: defaultSelect.content } : { type: "mutiple", selections: defaultSelect.selectLines, content: defaultSelect.content };
      setTimeout(() => {
        listener = plugin.listenDragAndDrop(e, info.content, handleDrop);
      });
    });
    return {
      reset: () => listener == null ? void 0 : listener.reset()
    };
  };
  const dragMarker = new class extends import_view.GutterMarker {
    destroy(dom) {
    }
    toDOM(view) {
      const dragSymbol = document.createElement("div");
      dragSymbol.draggable = true;
      const symbol = dragSymbol.createSpan();
      symbol.innerText = plugin.settings.dragSymbol;
      symbol.style.fontSize = `${plugin.settings.dragSymbolSize}px`;
      const { reset } = addDragStartEvent(dragSymbol, view);
      dragSymbol.addEventListener("dragend", () => {
        reset();
      });
      return dragSymbol;
    }
  }();
  const mousemoveEffect = import_state.StateEffect.define({
    map: (val, mapping) => ({ from: mapping.mapPos(val.from), to: mapping.mapPos(val.to) })
  });
  const dragSymbolSet = import_state.StateField.define({
    create() {
      return import_state.RangeSet.empty;
    },
    update(set, transaction) {
      set = set.map(transaction.changes);
      for (const e of transaction.effects) {
        if (e.is(mousemoveEffect)) {
          set = import_state.RangeSet.of(dragMarker.range(e.value.from));
        }
      }
      return set;
    },
    //依此stateField狀態所需要更新的Extension都可以放在provide funciton中提供出來
    provide: (value) => {
      const gut = (0, import_view.gutter)({
        class: "cn-drag-symbol",
        markers: (v) => {
          const range_set = v.state.field(value);
          return v.state.doc.length !== 0 ? range_set : import_state.RangeSet.empty;
        },
        initialSpacer: () => dragMarker
      });
      return [gut];
    }
  });
  const addSymbolWhenMouseMove = (event, view) => {
    const pos = view.posAtCoords({
      x: event.clientX,
      y: event.clientY
    });
    if (pos) {
      const dragLine = view.state.field(dragSymbolSet);
      const line = view.lineBlockAt(pos);
      let hasDragPoint = false;
      dragLine.between(line.from, line.from, () => {
        hasDragPoint = true;
      });
      if (!hasDragPoint) {
        view.dispatch({
          effects: mousemoveEffect.of({ from: line.from, to: line.to })
        });
      }
    }
    return pos;
  };
  const mouseMoveWatch = import_view.EditorView.domEventHandlers({
    mousemove: (event, view) => {
      throttle(addSymbolWhenMouseMove, 0.2)(event, view);
    }
  });
  return [
    dragSymbolSet,
    mouseMoveWatch
  ];
};

// src/view/cardSearchView.ts
var import_obsidian13 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block4, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block4(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance9, create_fragment11, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance9 ? instance9(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment11 ? create_fragment11($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/view/components/Search.svelte
var import_obsidian12 = require("obsidian");

// node_modules/svelte-window/src/timer.js
var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";
var now2 = hasNativePerformanceNow ? () => performance.now() : () => Date.now();
function cancelTimeout(timeoutID) {
  cancelAnimationFrame(timeoutID.id);
}
function requestTimeout(callback, delay) {
  const start = now2();
  function tick2() {
    if (now2() - start >= delay) {
      callback.call(null);
    } else {
      timeoutID.id = requestAnimationFrame(tick2);
    }
  }
  const timeoutID = {
    id: requestAnimationFrame(tick2)
  };
  return timeoutID;
}

// node_modules/svelte-window/src/domHelpers.js
var size = -1;
function getScrollbarSize(recalculate = false) {
  if (size === -1 || recalculate) {
    const div = document.createElement("div");
    const style = div.style;
    style.width = "50px";
    style.height = "50px";
    style.overflow = "scroll";
    document.body.appendChild(div);
    size = div.offsetWidth - div.clientWidth;
    document.body.removeChild(div);
  }
  return size;
}
var cachedRTLResult = null;
function getRTLOffsetType(recalculate = false) {
  if (cachedRTLResult === null || recalculate) {
    const outerDiv = document.createElement("div");
    const outerStyle = outerDiv.style;
    outerStyle.width = "50px";
    outerStyle.height = "50px";
    outerStyle.overflow = "scroll";
    outerStyle.direction = "rtl";
    const innerDiv = document.createElement("div");
    const innerStyle = innerDiv.style;
    innerStyle.width = "100px";
    innerStyle.height = "100px";
    outerDiv.appendChild(innerDiv);
    document.body.appendChild(outerDiv);
    if (outerDiv.scrollLeft > 0) {
      cachedRTLResult = "positive-descending";
    } else {
      outerDiv.scrollLeft = 1;
      if (outerDiv.scrollLeft === 0) {
        cachedRTLResult = "negative";
      } else {
        cachedRTLResult = "positive-ascending";
      }
    }
    document.body.removeChild(outerDiv);
    return cachedRTLResult;
  }
  return cachedRTLResult;
}

// node_modules/svelte-window/src/GridComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-duw07k", ".outerElement.svelte-duw07k{position:relative;overflow:auto;-webkit-overflow-scrolling:touch;will-change:transform}");
}
var get_default_slot_changes = (dirty) => ({ items: dirty[0] & /*items*/
256 });
var get_default_slot_context = (ctx) => ({ items: (
  /*items*/
  ctx[8]
) });
function create_fragment(ctx) {
  let div1;
  let div0;
  let div0_style_value;
  let div1_class_value;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[48].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[47],
    get_default_slot_context
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "style", div0_style_value = "height: " + /*estimatedTotalHeight*/
      ctx[9] + "px;" + /*isScrolling*/
      (ctx[7] ? "pointer-events: 'none';" : "") + "width: " + /*estimatedTotalWidth*/
      ctx[10] + "px;");
      attr(div1, "class", div1_class_value = null_to_empty(
        /*className*/
        ctx[2]
      ) + " svelte-duw07k");
      attr(div1, "style", div1_style_value = "height:" + (typeof /*height*/
      ctx[4] === "number" ? (
        /*height*/
        ctx[4] + "px"
      ) : (
        /*height*/
        ctx[4]
      )) + ";width:" + (typeof /*width*/
      ctx[6] === "number" ? (
        /*width*/
        ctx[6] + "px"
      ) : (
        /*width*/
        ctx[6]
      )) + ";direction:" + /*direction*/
      ctx[3] + ";" + /*style*/
      (ctx[5] || ""));
      toggle_class(div1, "outerElement", true);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[49](div0);
      ctx[50](div1);
      current = true;
      if (!mounted) {
        dispose = listen(
          div1,
          "scroll",
          /*_onScroll*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*items*/
        256 | dirty[1] & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[47],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[47]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[47],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*estimatedTotalHeight, isScrolling, estimatedTotalWidth*/
      1664 && div0_style_value !== (div0_style_value = "height: " + /*estimatedTotalHeight*/
      ctx2[9] + "px;" + /*isScrolling*/
      (ctx2[7] ? "pointer-events: 'none';" : "") + "width: " + /*estimatedTotalWidth*/
      ctx2[10] + "px;")) {
        attr(div0, "style", div0_style_value);
      }
      if (!current || dirty[0] & /*className*/
      4 && div1_class_value !== (div1_class_value = null_to_empty(
        /*className*/
        ctx2[2]
      ) + " svelte-duw07k")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*height, width, direction, style*/
      120 && div1_style_value !== (div1_style_value = "height:" + (typeof /*height*/
      ctx2[4] === "number" ? (
        /*height*/
        ctx2[4] + "px"
      ) : (
        /*height*/
        ctx2[4]
      )) + ";width:" + (typeof /*width*/
      ctx2[6] === "number" ? (
        /*width*/
        ctx2[6] + "px"
      ) : (
        /*width*/
        ctx2[6]
      )) + ";direction:" + /*direction*/
      ctx2[3] + ";" + /*style*/
      (ctx2[5] || ""))) {
        attr(div1, "style", div1_style_value);
      }
      if (!current || dirty[0] & /*className*/
      4) {
        toggle_class(div1, "outerElement", true);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[49](null);
      ctx[50](null);
      mounted = false;
      dispose();
    }
  };
}
var IS_SCROLLING_DEBOUNCE_INTERVAL = 150;
var defaultItemKey = ({ columnIndex, data, rowIndex }) => `${rowIndex}:${columnIndex}`;
function instance_1($$self, $$props, $$invalidate) {
  let itemKey_;
  let isScrollingRender;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { className = void 0 } = $$props;
  let { columnCount = void 0 } = $$props;
  let { columnWidth = void 0 } = $$props;
  let { direction = "ltr" } = $$props;
  let { height = void 0 } = $$props;
  let { initialScrollLeft = void 0 } = $$props;
  let { initialScrollTop = void 0 } = $$props;
  let { innerRef = void 0 } = $$props;
  let { innerElementType = void 0 } = $$props;
  let { innerTagName = void 0 } = $$props;
  let { itemData = void 0 } = $$props;
  let { itemKey = void 0 } = $$props;
  let { onItemsRendered = void 0 } = $$props;
  let { onScroll = void 0 } = $$props;
  let { outerRef = null } = $$props;
  let { outerElementType = void 0 } = $$props;
  let { outerTagName = void 0 } = $$props;
  let { overscanColumnCount = void 0 } = $$props;
  let { overscanColumnsCount = void 0 } = $$props;
  let { overscanCount = void 0 } = $$props;
  let { overscanRowCount = void 0 } = $$props;
  let { overscanRowsCount = void 0 } = $$props;
  let { rowCount = void 0 } = $$props;
  let { rowHeight = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { useIsScrolling = false } = $$props;
  let { width = void 0 } = $$props;
  let { specificFunctionProps } = $$props;
  const { getColumnOffset, getColumnStartIndexForOffset, getColumnStopIndexForStartIndex, getColumnWidth, getEstimatedTotalHeight, getEstimatedTotalWidth, getOffsetForColumnAndAlignment, getOffsetForRowAndAlignment, getRowHeight, getRowOffset, getRowStartIndexForOffset, getRowStopIndexForStartIndex, initInstanceProps, shouldResetStyleCacheOnItemSizeChange } = specificFunctionProps;
  let _styleCache = {}, _styleCacheCheck = {};
  const _getItemStyleCache = (a, b, c) => {
    if (a === _styleCacheCheck.a && b === _styleCacheCheck.b && c === _styleCacheCheck.c) {
      return _styleCache;
    }
    _styleCacheCheck = { a, b, c };
    _styleCache = {};
    return _styleCache;
  };
  const instance9 = { _getItemStyleCache };
  let props;
  let isScrolling = false, horizontalScrollDirection = "forward", scrollLeft = typeof initialScrollLeft === "number" ? initialScrollLeft : 0, scrollTop = typeof initialScrollTop === "number" ? initialScrollTop : 0, scrollUpdateWasRequested = false, verticalScrollDirection = "forward", _instanceProps, _resetIsScrollingTimeoutId = null;
  let request_resetIsScrollingDebounced = false, request_getItemStyleCache = false, items = [], estimatedTotalHeight, estimatedTotalWidth;
  const scrollTo = ({ scrollLeft: scrollLeft_, scrollTop: scrollTop_ }) => {
    request_resetIsScrollingDebounced = true;
    if (scrollLeft_ !== void 0) {
      scrollLeft_ = Math.max(0, scrollLeft_);
    }
    if (scrollTop_ !== void 0) {
      scrollTop_ = Math.max(0, scrollTop_);
    }
    if (scrollLeft_ === void 0) {
      scrollLeft_ = scrollLeft;
    }
    if (scrollTop_ === void 0) {
      scrollTop_ = scrollTop;
    }
    if (scrollLeft === scrollLeft_ && scrollTop === scrollTop_) {
      return null;
    }
    $$invalidate(38, horizontalScrollDirection = scrollLeft < scrollLeft_ ? "forward" : "backward");
    $$invalidate(39, scrollLeft = scrollLeft_);
    $$invalidate(40, scrollTop = scrollTop_);
    scrollUpdateWasRequested = true;
    $$invalidate(41, verticalScrollDirection = scrollTop < scrollTop_ ? "forward" : "backward");
  };
  const scrollToItem = ({ align = "auto", columnIndex, rowIndex }) => {
    const scrollbarSize = getScrollbarSize();
    if (columnIndex !== void 0) {
      columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));
    }
    if (rowIndex !== void 0) {
      rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));
    }
    const estimatedTotalHeight2 = getEstimatedTotalHeight(props, _instanceProps);
    const estimatedTotalWidth2 = getEstimatedTotalWidth(props, _instanceProps);
    const horizontalScrollbarSize = estimatedTotalWidth2 > width ? scrollbarSize : 0;
    const verticalScrollbarSize = estimatedTotalHeight2 > height ? scrollbarSize : 0;
    scrollTo({
      scrollLeft: columnIndex !== void 0 ? getOffsetForColumnAndAlignment(props, columnIndex, align, scrollLeft, _instanceProps, verticalScrollbarSize) : scrollLeft,
      scrollTop: rowIndex !== void 0 ? getOffsetForRowAndAlignment(props, rowIndex, align, scrollTop, _instanceProps, horizontalScrollbarSize) : scrollTop
    });
  };
  onMount(() => {
    if (outerRef != null) {
      if (typeof initialScrollLeft === "number") {
        $$invalidate(1, outerRef.scrollLeft = initialScrollLeft, outerRef);
      }
      if (typeof initialScrollTop === "number") {
        $$invalidate(1, outerRef.scrollTop = initialScrollTop, outerRef);
      }
    }
    _callPropsCallbacks();
  });
  onDestroy(() => {
    if (_resetIsScrollingTimeoutId !== null) {
      cancelTimeout(_resetIsScrollingTimeoutId);
    }
  });
  let columnStartIndex, columnStopIndex, rowStartIndex, rowStopIndex;
  const render = () => {
    if (columnCount > 0 && rowCount) {
      $$invalidate(8, items.length = (rowStopIndex - rowStartIndex + 1) * (columnStopIndex - columnStartIndex + 1), items);
      let i = 0;
      for (let rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
        for (let columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
          $$invalidate(
            8,
            items[i++] = {
              columnIndex,
              data: itemData,
              isScrolling: isScrollingRender,
              key: itemKey_({ columnIndex, data: itemData, rowIndex }),
              rowIndex,
              style: _getItemStyle(rowIndex, columnIndex)
            },
            items
          );
        }
      }
    }
    $$invalidate(9, estimatedTotalHeight = getEstimatedTotalHeight(props, _instanceProps));
    $$invalidate(10, estimatedTotalWidth = getEstimatedTotalWidth(props, _instanceProps));
  };
  let _onItemsRenderedCache = {}, _onScrollCache = {};
  const _callPropsCallbacks = () => {
    if (typeof onItemsRendered === "function") {
      if (columnCount > 0 && rowCount > 0) {
        const [
          overscanColumnStartIndex,
          overscanColumnStopIndex,
          visibleColumnStartIndex,
          visibleColumnStopIndex
        ] = _getHorizontalRangeToRender();
        const [
          overscanRowStartIndex,
          overscanRowStopIndex,
          visibleRowStartIndex,
          visibleRowStopIndex
        ] = _getVerticalRangeToRender();
        const ch2 = _onItemsRenderedCache;
        if (overscanColumnStartIndex !== ch2.overscanColumnStartIndex || overscanColumnStopIndex !== ch2.overscanColumnStopIndex || overscanRowStartIndex !== ch2.overscanRowStartIndex || overscanRowStopIndex !== ch2.overscanRowStopIndex || visibleColumnStartIndex !== ch2.visibleColumnStartIndex || visibleColumnStopIndex !== ch2.visibleColumnStopIndex || visibleRowStartIndex !== ch2.visibleRowStartIndex || visibleRowStopIndex !== ch2.visibleRowStopIndex) {
          onItemsRendered({
            overscanColumnStartIndex,
            overscanColumnStopIndex,
            overscanRowStartIndex,
            overscanRowStopIndex,
            visibleColumnStartIndex,
            visibleColumnStopIndex,
            visibleRowStartIndex,
            visibleRowStopIndex
          });
          _onItemsRenderedCache = {
            overscanColumnStartIndex,
            overscanColumnStopIndex,
            overscanRowStartIndex,
            overscanRowStopIndex,
            visibleColumnStartIndex,
            visibleColumnStopIndex,
            visibleRowStartIndex,
            visibleRowStopIndex
          };
        }
      }
    }
    const ch = _onScrollCache;
    if (typeof onScroll === "function" && !(scrollLeft === ch.scrollLeft && scrollTop === ch.scrollTop && horizontalScrollDirection === ch.horizontalScrollDirection && verticalScrollDirection === ch.verticalScrollDirection && scrollUpdateWasRequested === scrollUpdateWasRequested)) {
      onScroll({
        scrollLeft,
        scrollTop,
        horizontalScrollDirection,
        verticalScrollDirection,
        scrollUpdateWasRequested
      });
      _onScrollCache = {
        scrollLeft,
        scrollTop,
        horizontalScrollDirection,
        verticalScrollDirection,
        scrollUpdateWasRequested
      };
    }
  };
  const _getItemStyle = (rowIndex, columnIndex) => {
    const itemStyleCache = _getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);
    const key = `${rowIndex}:${columnIndex}`;
    let style2;
    if (itemStyleCache.hasOwnProperty(key)) {
      style2 = itemStyleCache[key];
    } else {
      const offset = getColumnOffset(props, columnIndex, _instanceProps);
      const isRtl = direction === "rtl";
      itemStyleCache[key] = style2 = {
        position: "absolute",
        left: isRtl ? void 0 : offset,
        right: isRtl ? offset : void 0,
        top: getRowOffset(props, rowIndex, _instanceProps),
        height: getRowHeight(props, rowIndex, _instanceProps),
        width: getColumnWidth(props, columnIndex, _instanceProps)
      };
    }
    return style2;
  };
  const _getHorizontalRangeToRender = () => {
    const overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;
    if (columnCount === 0 || rowCount === 0) {
      return [0, 0, 0, 0];
    }
    const startIndex = getColumnStartIndexForOffset(props, scrollLeft, _instanceProps);
    const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, _instanceProps);
    const overscanBackward = !isScrolling || horizontalScrollDirection === "backward" ? Math.max(1, overscanCountResolved) : 1;
    const overscanForward = !isScrolling || horizontalScrollDirection === "forward" ? Math.max(1, overscanCountResolved) : 1;
    return [
      Math.max(0, startIndex - overscanBackward),
      Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),
      startIndex,
      stopIndex
    ];
  };
  const _getVerticalRangeToRender = () => {
    const overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;
    if (columnCount === 0 || rowCount === 0) {
      return [0, 0, 0, 0];
    }
    const startIndex = getRowStartIndexForOffset(props, scrollTop, _instanceProps);
    const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, _instanceProps);
    const overscanBackward = !isScrolling || verticalScrollDirection === "backward" ? Math.max(1, overscanCountResolved) : 1;
    const overscanForward = !isScrolling || verticalScrollDirection === "forward" ? Math.max(1, overscanCountResolved) : 1;
    return [
      Math.max(0, startIndex - overscanBackward),
      Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),
      startIndex,
      stopIndex
    ];
  };
  const _onScroll = (event) => {
    const { clientHeight, clientWidth, scrollLeft: scrollLeft_, scrollTop: scrollTop_, scrollHeight, scrollWidth } = event.currentTarget;
    request_resetIsScrollingDebounced = true;
    if (scrollLeft === scrollLeft_ && scrollTop === scrollTop_) {
      return null;
    }
    let calculatedScrollLeft = scrollLeft_;
    if (direction === "rtl") {
      switch (getRTLOffsetType()) {
        case "negative":
          calculatedScrollLeft = -scrollLeft_;
          break;
        case "positive-descending":
          calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft_;
          break;
      }
    }
    calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));
    const calculatedscrollTop = Math.max(0, Math.min(scrollTop_, scrollHeight - clientHeight));
    $$invalidate(7, isScrolling = true);
    $$invalidate(38, horizontalScrollDirection = scrollLeft < scrollLeft_ ? "forward" : "backward");
    $$invalidate(39, scrollLeft = calculatedScrollLeft);
    $$invalidate(40, scrollTop = calculatedscrollTop);
    $$invalidate(41, verticalScrollDirection = scrollTop < scrollTop_ ? "forward" : "backward");
    scrollUpdateWasRequested = false;
  };
  const _resetIsScrollingDebounced = () => {
    if (_resetIsScrollingTimeoutId !== null) {
      cancelTimeout(_resetIsScrollingTimeoutId);
    }
    _resetIsScrollingTimeoutId = requestTimeout(_resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);
  };
  const _resetIsScrolling = () => {
    _resetIsScrollingTimeoutId = null;
    $$invalidate(7, isScrolling = false);
    $$invalidate(41, verticalScrollDirection = "");
    $$invalidate(38, horizontalScrollDirection = "");
    request_getItemStyleCache = true;
  };
  afterUpdate(() => {
    if (request_resetIsScrollingDebounced) {
      request_resetIsScrollingDebounced = false;
      _resetIsScrollingDebounced();
    }
    if (request_getItemStyleCache) {
      request_getItemStyleCache = false;
      _getItemStyleCache(-1);
    }
    if (scrollUpdateWasRequested && outerRef != null) {
      if (direction === "rtl") {
        switch (getRTLOffsetType()) {
          case "negative":
            $$invalidate(1, outerRef.scrollLeft = -scrollLeft, outerRef);
            break;
          case "positive-ascending":
            $$invalidate(1, outerRef.scrollLeft = scrollLeft, outerRef);
            break;
          default:
            const { clientWidth, scrollWidth } = outerRef;
            $$invalidate(1, outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft, outerRef);
            break;
        }
      } else {
        $$invalidate(1, outerRef.scrollLeft = Math.max(0, scrollLeft), outerRef);
      }
      $$invalidate(1, outerRef.scrollTop = Math.max(0, scrollTop), outerRef);
    }
    _callPropsCallbacks();
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      innerRef = $$value;
      $$invalidate(0, innerRef);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      outerRef = $$value;
      $$invalidate(1, outerRef);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("columnCount" in $$props2)
      $$invalidate(12, columnCount = $$props2.columnCount);
    if ("columnWidth" in $$props2)
      $$invalidate(13, columnWidth = $$props2.columnWidth);
    if ("direction" in $$props2)
      $$invalidate(3, direction = $$props2.direction);
    if ("height" in $$props2)
      $$invalidate(4, height = $$props2.height);
    if ("initialScrollLeft" in $$props2)
      $$invalidate(14, initialScrollLeft = $$props2.initialScrollLeft);
    if ("initialScrollTop" in $$props2)
      $$invalidate(15, initialScrollTop = $$props2.initialScrollTop);
    if ("innerRef" in $$props2)
      $$invalidate(0, innerRef = $$props2.innerRef);
    if ("innerElementType" in $$props2)
      $$invalidate(16, innerElementType = $$props2.innerElementType);
    if ("innerTagName" in $$props2)
      $$invalidate(17, innerTagName = $$props2.innerTagName);
    if ("itemData" in $$props2)
      $$invalidate(18, itemData = $$props2.itemData);
    if ("itemKey" in $$props2)
      $$invalidate(19, itemKey = $$props2.itemKey);
    if ("onItemsRendered" in $$props2)
      $$invalidate(20, onItemsRendered = $$props2.onItemsRendered);
    if ("onScroll" in $$props2)
      $$invalidate(21, onScroll = $$props2.onScroll);
    if ("outerRef" in $$props2)
      $$invalidate(1, outerRef = $$props2.outerRef);
    if ("outerElementType" in $$props2)
      $$invalidate(22, outerElementType = $$props2.outerElementType);
    if ("outerTagName" in $$props2)
      $$invalidate(23, outerTagName = $$props2.outerTagName);
    if ("overscanColumnCount" in $$props2)
      $$invalidate(24, overscanColumnCount = $$props2.overscanColumnCount);
    if ("overscanColumnsCount" in $$props2)
      $$invalidate(25, overscanColumnsCount = $$props2.overscanColumnsCount);
    if ("overscanCount" in $$props2)
      $$invalidate(26, overscanCount = $$props2.overscanCount);
    if ("overscanRowCount" in $$props2)
      $$invalidate(27, overscanRowCount = $$props2.overscanRowCount);
    if ("overscanRowsCount" in $$props2)
      $$invalidate(28, overscanRowsCount = $$props2.overscanRowsCount);
    if ("rowCount" in $$props2)
      $$invalidate(29, rowCount = $$props2.rowCount);
    if ("rowHeight" in $$props2)
      $$invalidate(30, rowHeight = $$props2.rowHeight);
    if ("style" in $$props2)
      $$invalidate(5, style = $$props2.style);
    if ("useIsScrolling" in $$props2)
      $$invalidate(31, useIsScrolling = $$props2.useIsScrolling);
    if ("width" in $$props2)
      $$invalidate(6, width = $$props2.width);
    if ("specificFunctionProps" in $$props2)
      $$invalidate(32, specificFunctionProps = $$props2.specificFunctionProps);
    if ("$$scope" in $$props2)
      $$invalidate(47, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*className, columnCount, columnWidth, direction, height, initialScrollLeft, initialScrollTop, innerElementType, innerTagName, itemData, itemKey, onItemsRendered, onScroll, outerElementType, outerTagName, overscanColumnCount, overscanColumnsCount, overscanCount, overscanRowCount, overscanRowsCount, rowCount, rowHeight, style, width*/
    2147479676 | $$self.$$.dirty[1] & /*useIsScrolling*/
    1) {
      $:
        $$invalidate(37, props = {
          className,
          columnCount,
          columnWidth,
          direction,
          height,
          initialScrollLeft,
          initialScrollTop,
          //innerRef,
          innerElementType,
          innerTagName,
          itemData,
          itemKey,
          onItemsRendered,
          onScroll,
          //outerRef,
          outerElementType,
          outerTagName,
          overscanColumnCount,
          overscanColumnsCount,
          overscanCount,
          overscanRowCount,
          overscanRowsCount,
          rowCount,
          rowHeight,
          style,
          useIsScrolling,
          width
        });
    }
    if ($$self.$$.dirty[1] & /*props*/
    64) {
      $:
        _instanceProps = instance9 && initInstanceProps(props, instance9);
    }
    if ($$self.$$.dirty[0] & /*itemKey*/
    524288) {
      $:
        itemKey_ = itemKey || defaultItemKey;
    }
    if ($$self.$$.dirty[1] & /*props, scrollLeft, horizontalScrollDirection*/
    448) {
      $:
        $$invalidate(42, [columnStartIndex, columnStopIndex] = _getHorizontalRangeToRender(props, scrollLeft, horizontalScrollDirection), columnStartIndex, ($$invalidate(43, columnStopIndex), $$invalidate(37, props), $$invalidate(39, scrollLeft), $$invalidate(38, horizontalScrollDirection), $$invalidate(2, className), $$invalidate(12, columnCount), $$invalidate(13, columnWidth), $$invalidate(3, direction), $$invalidate(4, height), $$invalidate(14, initialScrollLeft), $$invalidate(15, initialScrollTop), $$invalidate(16, innerElementType), $$invalidate(17, innerTagName), $$invalidate(18, itemData), $$invalidate(19, itemKey), $$invalidate(20, onItemsRendered), $$invalidate(21, onScroll), $$invalidate(22, outerElementType), $$invalidate(23, outerTagName), $$invalidate(24, overscanColumnCount), $$invalidate(25, overscanColumnsCount), $$invalidate(26, overscanCount), $$invalidate(27, overscanRowCount), $$invalidate(28, overscanRowsCount), $$invalidate(29, rowCount), $$invalidate(30, rowHeight), $$invalidate(5, style), $$invalidate(31, useIsScrolling), $$invalidate(6, width)));
    }
    if ($$self.$$.dirty[1] & /*props, scrollTop, verticalScrollDirection*/
    1600) {
      $:
        $$invalidate(44, [rowStartIndex, rowStopIndex] = _getVerticalRangeToRender(props, scrollTop, verticalScrollDirection), rowStartIndex, ($$invalidate(45, rowStopIndex), $$invalidate(37, props), $$invalidate(40, scrollTop), $$invalidate(41, verticalScrollDirection), $$invalidate(2, className), $$invalidate(12, columnCount), $$invalidate(13, columnWidth), $$invalidate(3, direction), $$invalidate(4, height), $$invalidate(14, initialScrollLeft), $$invalidate(15, initialScrollTop), $$invalidate(16, innerElementType), $$invalidate(17, innerTagName), $$invalidate(18, itemData), $$invalidate(19, itemKey), $$invalidate(20, onItemsRendered), $$invalidate(21, onScroll), $$invalidate(22, outerElementType), $$invalidate(23, outerTagName), $$invalidate(24, overscanColumnCount), $$invalidate(25, overscanColumnsCount), $$invalidate(26, overscanCount), $$invalidate(27, overscanRowCount), $$invalidate(28, overscanRowsCount), $$invalidate(29, rowCount), $$invalidate(30, rowHeight), $$invalidate(5, style), $$invalidate(31, useIsScrolling), $$invalidate(6, width)));
    }
    if ($$self.$$.dirty[0] & /*isScrolling*/
    128 | $$self.$$.dirty[1] & /*useIsScrolling*/
    1) {
      $:
        $$invalidate(46, isScrollingRender = useIsScrolling ? isScrolling : void 0);
    }
    if ($$self.$$.dirty[0] & /*columnCount, columnWidth, height, innerElementType, innerTagName, itemData, itemKey, outerElementType, outerTagName, rowCount, rowHeight, width*/
    1624191056 | $$self.$$.dirty[1] & /*columnStartIndex, columnStopIndex, rowStartIndex, rowStopIndex, useIsScrolling, isScrollingRender*/
    63489) {
      $: {
        render(columnStartIndex, columnStopIndex, rowStartIndex, rowStopIndex, columnCount, columnWidth, height, innerElementType, innerTagName, itemData, itemKey, outerElementType, outerTagName, rowCount, rowHeight, useIsScrolling, width, isScrollingRender);
      }
    }
  };
  return [
    innerRef,
    outerRef,
    className,
    direction,
    height,
    style,
    width,
    isScrolling,
    items,
    estimatedTotalHeight,
    estimatedTotalWidth,
    _onScroll,
    columnCount,
    columnWidth,
    initialScrollLeft,
    initialScrollTop,
    innerElementType,
    innerTagName,
    itemData,
    itemKey,
    onItemsRendered,
    onScroll,
    outerElementType,
    outerTagName,
    overscanColumnCount,
    overscanColumnsCount,
    overscanCount,
    overscanRowCount,
    overscanRowsCount,
    rowCount,
    rowHeight,
    useIsScrolling,
    specificFunctionProps,
    _getItemStyleCache,
    instance9,
    scrollTo,
    scrollToItem,
    props,
    horizontalScrollDirection,
    scrollLeft,
    scrollTop,
    verticalScrollDirection,
    columnStartIndex,
    columnStopIndex,
    rowStartIndex,
    rowStopIndex,
    isScrollingRender,
    $$scope,
    slots,
    div0_binding,
    div1_binding
  ];
}
var GridComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        className: 2,
        columnCount: 12,
        columnWidth: 13,
        direction: 3,
        height: 4,
        initialScrollLeft: 14,
        initialScrollTop: 15,
        innerRef: 0,
        innerElementType: 16,
        innerTagName: 17,
        itemData: 18,
        itemKey: 19,
        onItemsRendered: 20,
        onScroll: 21,
        outerRef: 1,
        outerElementType: 22,
        outerTagName: 23,
        overscanColumnCount: 24,
        overscanColumnsCount: 25,
        overscanCount: 26,
        overscanRowCount: 27,
        overscanRowsCount: 28,
        rowCount: 29,
        rowHeight: 30,
        style: 5,
        useIsScrolling: 31,
        width: 6,
        specificFunctionProps: 32,
        _getItemStyleCache: 33,
        instance: 34,
        scrollTo: 35,
        scrollToItem: 36
      },
      add_css,
      [-1, -1, -1]
    );
  }
  get _getItemStyleCache() {
    return this.$$.ctx[33];
  }
  get instance() {
    return this.$$.ctx[34];
  }
  get scrollTo() {
    return this.$$.ctx[35];
  }
  get scrollToItem() {
    return this.$$.ctx[36];
  }
};
var GridComponent_default = GridComponent;

// node_modules/svelte-window/src/FixedSizeGrid.js
var FixedSizeGridSpecificProps = {
  getColumnOffset: ({ columnWidth }, index) => index * columnWidth,
  getColumnWidth: ({ columnWidth }, index) => columnWidth,
  getRowOffset: ({ rowHeight }, index) => index * rowHeight,
  getRowHeight: ({ rowHeight }, index) => rowHeight,
  getEstimatedTotalHeight: ({ rowCount, rowHeight }) => rowHeight * rowCount,
  getEstimatedTotalWidth: ({ columnCount, columnWidth }) => columnWidth * columnCount,
  getOffsetForColumnAndAlignment: ({ columnCount, columnWidth, width }, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) => {
    const lastColumnOffset = Math.max(
      0,
      columnCount * columnWidth - width
    );
    const maxOffset = Math.min(
      lastColumnOffset,
      columnIndex * columnWidth
    );
    const minOffset = Math.max(
      0,
      columnIndex * columnWidth - width + scrollbarSize + columnWidth
    );
    if (align === "smart") {
      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        const middleOffset = Math.round(
          minOffset + (maxOffset - minOffset) / 2
        );
        if (middleOffset < Math.ceil(width / 2)) {
          return 0;
        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {
          return lastColumnOffset;
        } else {
          return middleOffset;
        }
      case "auto":
      default:
        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {
          return scrollLeft;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollLeft < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getOffsetForRowAndAlignment: ({ rowHeight, height, rowCount }, rowIndex, align, scrollTop, instanceProps, scrollbarSize) => {
    const lastRowOffset = Math.max(
      0,
      rowCount * rowHeight - height
    );
    const maxOffset = Math.min(
      lastRowOffset,
      rowIndex * rowHeight
    );
    const minOffset = Math.max(
      0,
      rowIndex * rowHeight - height + scrollbarSize + rowHeight
    );
    if (align === "smart") {
      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {
        align = "auto";
      } else {
        align = "center";
      }
    }
    switch (align) {
      case "start":
        return maxOffset;
      case "end":
        return minOffset;
      case "center":
        const middleOffset = Math.round(
          minOffset + (maxOffset - minOffset) / 2
        );
        if (middleOffset < Math.ceil(height / 2)) {
          return 0;
        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {
          return lastRowOffset;
        } else {
          return middleOffset;
        }
      case "auto":
      default:
        if (scrollTop >= minOffset && scrollTop <= maxOffset) {
          return scrollTop;
        } else if (minOffset > maxOffset) {
          return minOffset;
        } else if (scrollTop < minOffset) {
          return minOffset;
        } else {
          return maxOffset;
        }
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth, columnCount }, scrollLeft) => Math.max(
    0,
    Math.min(
      columnCount - 1,
      Math.floor(scrollLeft / columnWidth)
    )
  ),
  getColumnStopIndexForStartIndex: ({ columnWidth, columnCount, width }, startIndex, scrollLeft) => {
    const left = startIndex * columnWidth;
    const numVisibleColumns = Math.ceil(
      (width + scrollLeft - left) / columnWidth
    );
    return Math.max(
      0,
      Math.min(
        columnCount - 1,
        startIndex + numVisibleColumns - 1
        // -1 is because stop index is inclusive
      )
    );
  },
  getRowStartIndexForOffset: ({ rowHeight, rowCount }, scrollTop) => Math.max(
    0,
    Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight))
  ),
  getRowStopIndexForStartIndex: ({ rowHeight, rowCount, height }, startIndex, scrollTop) => {
    const top = startIndex * rowHeight;
    const numVisibleRows = Math.ceil(
      (height + scrollTop - top) / rowHeight
    );
    return Math.max(
      0,
      Math.min(
        rowCount - 1,
        startIndex + numVisibleRows - 1
        // -1 is because stop index is inclusive
      )
    );
  },
  initInstanceProps(props) {
  },
  shouldResetStyleCacheOnItemSizeChange: true,
  validateProps: ({ columnWidth, rowHeight }) => {
    if (true) {
      if (typeof columnWidth !== "number") {
        throw Error(
          `An invalid "columnWidth" prop has been specified. Value should be a number. "${columnWidth === null ? "null" : typeof columnWidth}" was specified.`
        );
      }
      if (typeof rowHeight !== "number") {
        throw Error(
          `An invalid "rowHeight" prop has been specified. Value should be a number. "${rowHeight === null ? "null" : typeof rowHeight}" was specified.`
        );
      }
    }
  }
};
var FixedSizeGrid_default = FixedSizeGridSpecificProps;

// node_modules/svelte-window/lib/FixedSizeGrid.svelte
var get_default_slot_changes2 = (dirty) => ({ items: dirty & /*items*/
512 });
var get_default_slot_context2 = (ctx) => ({ items: (
  /*items*/
  ctx[9]
) });
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context2
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, items*/
        640)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let gridcomponent;
  let current;
  const gridcomponent_spread_levels = [
    { specificFunctionProps: FixedSizeGrid_default },
    /*$$restProps*/
    ctx[1]
  ];
  let gridcomponent_props = {
    $$slots: {
      default: [
        create_default_slot,
        ({ items }) => ({ 9: items }),
        ({ items }) => items ? 512 : 0
      ]
    },
    $$scope: { ctx }
  };
  for (let i = 0; i < gridcomponent_spread_levels.length; i += 1) {
    gridcomponent_props = assign(gridcomponent_props, gridcomponent_spread_levels[i]);
  }
  gridcomponent = new GridComponent_default({ props: gridcomponent_props });
  ctx[6](gridcomponent);
  return {
    c() {
      create_component(gridcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridcomponent, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const gridcomponent_changes = dirty & /*$$restProps*/
      2 ? get_spread_update(gridcomponent_spread_levels, [
        gridcomponent_spread_levels[0],
        get_spread_object(
          /*$$restProps*/
          ctx2[1]
        )
      ]) : {};
      if (dirty & /*$$scope, items*/
      640) {
        gridcomponent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gridcomponent.$set(gridcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[6](null);
      destroy_component(gridcomponent, detaching);
    }
  };
}
function instance_12($$self, $$props, $$invalidate) {
  const omit_props_names = ["scrollTo", "scrollToItem", "instance"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let g;
  const scrollTo = (x) => g == null ? void 0 : g.scrollTo(x);
  const scrollToItem = (x) => g == null ? void 0 : g.scrollToItem(x);
  let inst = {};
  const instance9 = inst;
  function gridcomponent_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      g = $$value;
      $$invalidate(0, g);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*g*/
    1) {
      $:
        if (g) {
          Object.assign(inst, g.instance);
        }
    }
  };
  return [
    g,
    $$restProps,
    scrollTo,
    scrollToItem,
    instance9,
    slots,
    gridcomponent_binding,
    $$scope
  ];
}
var FixedSizeGrid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance_12, create_fragment2, safe_not_equal, {
      scrollTo: 2,
      scrollToItem: 3,
      instance: 4
    });
  }
  get scrollTo() {
    return this.$$.ctx[2];
  }
  get scrollToItem() {
    return this.$$.ctx[3];
  }
  get instance() {
    return this.$$.ctx[4];
  }
};
var FixedSizeGrid_default2 = FixedSizeGrid;

// node_modules/svelte-window/src/styleString.js
var styleString = (s) => (s.position !== void 0 ? "position: " + s.position + ";" : "") + (s.left !== void 0 ? "left: " + s.left + "px;" : "") + (s.right !== void 0 ? "right: " + s.right + "px;" : "") + (s.top !== void 0 ? "top: " + s.top + "px;" : "") + (s.height !== void 0 ? "height: " + (typeof s.height === "number" ? s.height + "px" : s.height) + ";" : "") + (s.width !== void 0 ? "width: " + (typeof s.width === "number" ? s.width + "px" : s.width) + ";" : "");

// node_modules/svelte-virtualized-auto-sizer/DetectElementResize.js
function createDetectElementResize(nonce) {
  var _window;
  if (typeof window !== "undefined") {
    _window = window;
  } else if (typeof self !== "undefined") {
    _window = self;
  } else {
    _window = global;
  }
  var attachEvent = typeof document !== "undefined" && document.attachEvent;
  if (!attachEvent) {
    var requestFrame = function() {
      var raf2 = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function(fn) {
        return _window.setTimeout(fn, 20);
      };
      return function(fn) {
        return raf2(fn);
      };
    }();
    var cancelFrame = function() {
      var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
      return function(id) {
        return cancel(id);
      };
    }();
    var resetTriggers = function resetTriggers2(element2) {
      var triggers = element2.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
      contract.scrollLeft = contract.scrollWidth;
      contract.scrollTop = contract.scrollHeight;
      expandChild.style.width = expand.offsetWidth + 1 + "px";
      expandChild.style.height = expand.offsetHeight + 1 + "px";
      expand.scrollLeft = expand.scrollWidth;
      expand.scrollTop = expand.scrollHeight;
    };
    var checkTriggers = function checkTriggers2(element2) {
      return element2.offsetWidth != element2.__resizeLast__.width || element2.offsetHeight != element2.__resizeLast__.height;
    };
    var scrollListener = function scrollListener2(e) {
      if (e.target.className && typeof e.target.className.indexOf === "function" && e.target.className.indexOf("contract-trigger") < 0 && e.target.className.indexOf("expand-trigger") < 0) {
        return;
      }
      var element2 = this;
      resetTriggers(this);
      if (this.__resizeRAF__) {
        cancelFrame(this.__resizeRAF__);
      }
      this.__resizeRAF__ = requestFrame(function() {
        if (checkTriggers(element2)) {
          element2.__resizeLast__.width = element2.offsetWidth;
          element2.__resizeLast__.height = element2.offsetHeight;
          element2.__resizeListeners__.forEach(function(fn) {
            fn.call(element2, e);
          });
        }
      });
    };
    var animation = false, keyframeprefix = "", animationstartevent = "animationstart", domPrefixes = "Webkit Moz O ms".split(" "), startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), pfx = "";
    {
      var elm = document.createElement("fakeelement");
      if (elm.style.animationName !== void 0) {
        animation = true;
      }
      if (animation === false) {
        for (var i = 0; i < domPrefixes.length; i++) {
          if (elm.style[domPrefixes[i] + "AnimationName"] !== void 0) {
            pfx = domPrefixes[i];
            keyframeprefix = "-" + pfx.toLowerCase() + "-";
            animationstartevent = startEvents[i];
            animation = true;
            break;
          }
        }
      }
    }
    var animationName = "resizeanim";
    var animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ";
    var animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
  }
  var createStyles = function createStyles2(doc) {
    if (!doc.getElementById("detectElementResize")) {
      var css = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style = doc.createElement("style");
      style.id = "detectElementResize";
      style.type = "text/css";
      if (nonce != null) {
        style.setAttribute("nonce", nonce);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(doc.createTextNode(css));
      }
      head.appendChild(style);
    }
  };
  var addResizeListener = function addResizeListener2(element2, fn) {
    if (attachEvent) {
      element2.attachEvent("onresize", fn);
    } else {
      if (!element2.__resizeTriggers__) {
        var doc = element2.ownerDocument;
        var elementStyle = _window.getComputedStyle(element2);
        if (elementStyle && elementStyle.position == "static") {
          element2.style.position = "relative";
        }
        createStyles(doc);
        element2.__resizeLast__ = {};
        element2.__resizeListeners__ = [];
        (element2.__resizeTriggers__ = doc.createElement("div")).className = "resize-triggers";
        var expandTrigger = doc.createElement("div");
        expandTrigger.className = "expand-trigger";
        expandTrigger.appendChild(doc.createElement("div"));
        var contractTrigger = doc.createElement("div");
        contractTrigger.className = "contract-trigger";
        element2.__resizeTriggers__.appendChild(expandTrigger);
        element2.__resizeTriggers__.appendChild(contractTrigger);
        element2.appendChild(element2.__resizeTriggers__);
        resetTriggers(element2);
        element2.addEventListener("scroll", scrollListener, true);
        if (animationstartevent) {
          element2.__resizeTriggers__.__animationListener__ = function animationListener(e) {
            if (e.animationName == animationName) {
              resetTriggers(element2);
            }
          };
          element2.__resizeTriggers__.addEventListener(animationstartevent, element2.__resizeTriggers__.__animationListener__);
        }
      }
      element2.__resizeListeners__.push(fn);
    }
  };
  var removeResizeListener = function removeResizeListener2(element2, fn) {
    if (attachEvent) {
      element2.detachEvent("onresize", fn);
    } else {
      element2.__resizeListeners__.splice(element2.__resizeListeners__.indexOf(fn), 1);
      if (!element2.__resizeListeners__.length) {
        element2.removeEventListener("scroll", scrollListener, true);
        if (element2.__resizeTriggers__.__animationListener__) {
          element2.__resizeTriggers__.removeEventListener(animationstartevent, element2.__resizeTriggers__.__animationListener__);
          element2.__resizeTriggers__.__animationListener__ = null;
        }
        try {
          element2.__resizeTriggers__ = !element2.removeChild(element2.__resizeTriggers__);
        } catch (e) {
        }
      }
    }
  };
  return {
    addResizeListener,
    removeResizeListener
  };
}

// node_modules/svelte-virtualized-auto-sizer/AutoSizer.svelte
function add_css2(target) {
  append_styles(target, "svelte-1fps6z5", "div.svelte-1fps6z5{overflow:visible}.outerstylewidth.svelte-1fps6z5{width:0}.outerstyleheight.svelte-1fps6z5{height:0}");
}
var get_default_slot_changes3 = (dirty) => ({
  width: dirty & /*childParams*/
  4,
  height: dirty & /*childParams*/
  4
});
var get_default_slot_context3 = (ctx) => ({
  width: (
    /*childParams*/
    ctx[2].width
  ),
  height: (
    /*childParams*/
    ctx[2].height
  )
});
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_default_slot_context3
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, childParams*/
        16388)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let div;
  let div_class_value;
  let current;
  let if_block = !/*bailoutOnChildren*/
  ctx[3] && create_if_block(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", div_class_value = null_to_empty(
        /*className*/
        ctx[0]
      ) + " svelte-1fps6z5");
      toggle_class(
        div,
        "outerstylewidth",
        /*outerstylewidth*/
        ctx[4]
      );
      toggle_class(
        div,
        "outerstyleheight",
        /*outerstyleheight*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      ctx[16](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*bailoutOnChildren*/
      ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*bailoutOnChildren*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*className*/
      1 && div_class_value !== (div_class_value = null_to_empty(
        /*className*/
        ctx2[0]
      ) + " svelte-1fps6z5")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*className, outerstylewidth*/
      17) {
        toggle_class(
          div,
          "outerstylewidth",
          /*outerstylewidth*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*className, outerstyleheight*/
      33) {
        toggle_class(
          div,
          "outerstyleheight",
          /*outerstyleheight*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      ctx[16](null);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { onResize = () => {
  } } = $$props;
  let { disableHeight = false } = $$props;
  let { disableWidth = false } = $$props;
  let { className = "" } = $$props;
  let { defaultHeight = void 0 } = $$props;
  let { defaultWidth = void 0 } = $$props;
  let { nonce = void 0 } = $$props;
  let height = defaultHeight || 0, width = defaultWidth || 0;
  let _parentNode, _autoSizer, _detectElementResize;
  const _onResize = () => {
    if (_parentNode) {
      const height_ = _parentNode.offsetHeight || 0;
      const width_ = _parentNode.offsetWidth || 0;
      const style = window.getComputedStyle(_parentNode) || {};
      const paddingLeft = parseInt(style.paddingLeft, 10) || 0;
      const paddingRight = parseInt(style.paddingRight, 10) || 0;
      const paddingTop = parseInt(style.paddingTop, 10) || 0;
      const paddingBottom = parseInt(style.paddingBottom, 10) || 0;
      const newHeight = height_ - paddingTop - paddingBottom;
      const newWidth = width_ - paddingLeft - paddingRight;
      if (!disableHeight && height !== newHeight || !disableWidth && width !== newWidth) {
        $$invalidate(12, height = height_ - paddingTop - paddingBottom);
        $$invalidate(13, width = width_ - paddingLeft - paddingRight);
        onResize({ height, width });
      }
    }
  };
  onMount(() => {
    if (_autoSizer && _autoSizer.parentNode && _autoSizer.parentNode.ownerDocument && _autoSizer.parentNode.ownerDocument.defaultView && _autoSizer.parentNode instanceof _autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {
      _parentNode = _autoSizer.parentNode;
      _detectElementResize = createDetectElementResize(nonce);
      _detectElementResize.addResizeListener(_parentNode, _onResize);
      _onResize();
    }
  });
  onDestroy(() => {
    if (_detectElementResize && _parentNode) {
      _detectElementResize.removeResizeListener(_parentNode, _onResize);
    }
  });
  const childParams = {};
  let bailoutOnChildren = false, outerstylewidth = false, outerstyleheight = false;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      _autoSizer = $$value;
      $$invalidate(1, _autoSizer);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("onResize" in $$props2)
      $$invalidate(6, onResize = $$props2.onResize);
    if ("disableHeight" in $$props2)
      $$invalidate(7, disableHeight = $$props2.disableHeight);
    if ("disableWidth" in $$props2)
      $$invalidate(8, disableWidth = $$props2.disableWidth);
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("defaultHeight" in $$props2)
      $$invalidate(9, defaultHeight = $$props2.defaultHeight);
    if ("defaultWidth" in $$props2)
      $$invalidate(10, defaultWidth = $$props2.defaultWidth);
    if ("nonce" in $$props2)
      $$invalidate(11, nonce = $$props2.nonce);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*disableHeight, height, disableWidth, width*/
    12672) {
      $: {
        $$invalidate(3, bailoutOnChildren = false);
        if (!disableHeight) {
          if (height === 0) {
            $$invalidate(3, bailoutOnChildren = true);
          }
          $$invalidate(5, outerstyleheight = true);
          $$invalidate(2, childParams.height = height, childParams);
        }
        if (!disableWidth) {
          if (width === 0) {
            $$invalidate(3, bailoutOnChildren = true);
          }
          $$invalidate(4, outerstylewidth = true);
          $$invalidate(2, childParams.width = width, childParams);
        }
      }
    }
  };
  return [
    className,
    _autoSizer,
    childParams,
    bailoutOnChildren,
    outerstylewidth,
    outerstyleheight,
    onResize,
    disableHeight,
    disableWidth,
    defaultHeight,
    defaultWidth,
    nonce,
    height,
    width,
    $$scope,
    slots,
    div_binding
  ];
}
var AutoSizer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment3,
      safe_not_equal,
      {
        onResize: 6,
        disableHeight: 7,
        disableWidth: 8,
        className: 0,
        defaultHeight: 9,
        defaultWidth: 10,
        nonce: 11
      },
      add_css2
    );
  }
};
var AutoSizer_default = AutoSizer;

// node_modules/svelte-virtualized-auto-sizer/index.js
var svelte_virtualized_auto_sizer_default = AutoSizer_default;

// src/view/components/ComputeLayout.svelte
var get_default_slot_changes4 = (dirty) => ({
  gridProps: dirty & /*columns, rows, viewHeight, residueSpace*/
  15
});
var get_default_slot_context4 = (ctx) => ({
  gridProps: {
    columns: (
      /*columns*/
      ctx[1]
    ),
    rows: (
      /*rows*/
      ctx[2]
    ),
    viewHeight: (
      /*viewHeight*/
      ctx[0]
    ),
    padding: (
      /*residueSpace*/
      ctx[3] >= 0 ? (
        /*residueSpace*/
        ctx[3]
      ) : 0
    )
  }
});
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context4
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, columns, rows, viewHeight, residueSpace*/
        271)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { viewHeight } = $$props;
  let { viewWidth } = $$props;
  let { columnWidth } = $$props;
  let { gap } = $$props;
  let { totalCount } = $$props;
  let columns, rows, residueSpace = 0;
  $$self.$$set = ($$props2) => {
    if ("viewHeight" in $$props2)
      $$invalidate(0, viewHeight = $$props2.viewHeight);
    if ("viewWidth" in $$props2)
      $$invalidate(4, viewWidth = $$props2.viewWidth);
    if ("columnWidth" in $$props2)
      $$invalidate(5, columnWidth = $$props2.columnWidth);
    if ("gap" in $$props2)
      $$invalidate(6, gap = $$props2.gap);
    if ("totalCount" in $$props2)
      $$invalidate(7, totalCount = $$props2.totalCount);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*columnWidth, gap, viewWidth, totalCount, columns*/
    242) {
      $: {
        const acutualColumnWidth = columnWidth + gap;
        const col = Math.floor(viewWidth / acutualColumnWidth);
        $$invalidate(1, columns = col === 0 ? 1 : col);
        $$invalidate(2, rows = Math.ceil(totalCount / columns));
        $$invalidate(3, residueSpace = (viewWidth - columns * acutualColumnWidth) / 2);
      }
    }
  };
  return [
    viewHeight,
    columns,
    rows,
    residueSpace,
    viewWidth,
    columnWidth,
    gap,
    totalCount,
    $$scope,
    slots
  ];
}
var ComputeLayout = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment4, safe_not_equal, {
      viewHeight: 0,
      viewWidth: 4,
      columnWidth: 5,
      gap: 6,
      totalCount: 7
    });
  }
};
var ComputeLayout_default = ComputeLayout;

// src/view/components/ButtonGroups.svelte
var import_obsidian5 = require("obsidian");
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div;
  let renderIcon_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(renderIcon_action = /*renderIcon*/
        ctx[1].call(
          null,
          div,
          /*but*/
          ctx[6]
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (renderIcon_action && is_function(renderIcon_action.update) && dirty & /*buttons*/
      1)
        renderIcon_action.update.call(
          null,
          /*but*/
          ctx[6]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment5(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*buttons*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*buttons*/
      1) {
        each_value = ensure_array_like(
          /*buttons*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { buttons = [] } = $$props;
  let { onclick } = $$props;
  let active = "";
  let unActive = () => {
  };
  const setUnActiveButton = (butt) => {
    unActive = () => {
      butt.removeCta();
    };
  };
  const renderIcon = (el, but) => {
    const b = new import_obsidian5.ButtonComponent(el).setIcon(but.icon).setTooltip(but.toolTip).onClick((e) => {
      if (active !== but.icon) {
        b.setCta();
        unActive();
        onclick(e, but.value);
        active = but.icon;
        setUnActiveButton(b);
      }
    });
    if (but.active) {
      b.setCta();
      active = but.icon;
      setUnActiveButton(b);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
    if ("onclick" in $$props2)
      $$invalidate(2, onclick = $$props2.onclick);
  };
  return [buttons, renderIcon, onclick];
}
var ButtonGroups = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment5, safe_not_equal, { buttons: 0, onclick: 2 });
  }
};
var ButtonGroups_default = ButtonGroups;

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/file.ts
var import_obsidian6 = require("obsidian");
function isSearchedFile(file) {
  return "content" in file;
}
function search(query) {
  const fuzzy = (0, import_obsidian6.prepareSimpleSearch)(query), searching = async (file, content) => {
    const contentResult = fuzzy(content), filePathResult = fuzzy(file.path);
    if (contentResult || filePathResult) {
      return {
        file,
        content,
        match: contentResult != null ? contentResult : void 0,
        nameMatch: filePathResult != null ? filePathResult : void 0
      };
    }
  };
  return searching;
}
function searchByRegex(query, flags) {
  return (file, content) => {
    const contentMatches = regexSearch(content, tryCreateRegex(query, flags));
    const filePathMatches = regexSearch(file.path, tryCreateRegex(query, flags));
    if (contentMatches.length !== 0 || filePathMatches.length !== 0) {
      return {
        file,
        content,
        match: { score: contentMatches.length, matches: contentMatches },
        nameMatch: { score: filePathMatches.length, matches: filePathMatches }
      };
    }
  };
}
function regexSearch(content, regex) {
  if (regex) {
    let matches = [];
    while (regex.lastIndex < content.length) {
      const match = regex.exec(content);
      if (match) {
        matches.push([match.index, regex.lastIndex]);
        continue;
      } else {
        break;
      }
    }
    return matches;
  }
  return [];
}
function sortByName(a, b) {
  return a.file.path < b.file.path ? -1 : a.file.path > b.file.path ? 1 : 0;
}
function sortByModifiedTime(a, b) {
  return a.file.stat.mtime - b.file.stat.mtime;
}
function sortByCreateTime(a, b) {
  return a.file.stat.ctime - b.file.stat.ctime;
}
function sortByRelated(a, b) {
  return computeScore(a) - computeScore(b);
}
function computeScore(value) {
  var _a, _b, _c, _d;
  return ((_b = (_a = value.match) == null ? void 0 : _a.score) != null ? _b : -5) + ((_d = (_c = value.nameMatch) == null ? void 0 : _c.score) != null ? _d : -5);
}
function Touch(source) {
  const [from, to] = source;
  return (target) => {
    const [start, end] = target;
    return end >= from && end <= to || start >= from && start <= to || start <= from && end >= to;
  };
}
function InRange(source) {
  const [from, to] = source;
  return (target) => {
    const [start, end] = target;
    return from <= start && end <= to;
  };
}
function ObsidianMarkdownRender(element2, para) {
  import_obsidian6.MarkdownRenderer.render(
    para.app,
    para.markdown,
    element2,
    para.sourcePath,
    para.component
  );
}
var validCacheReadFilesExtension = ["md", "canvas"];

// src/view/components/Card.svelte
var import_obsidian8 = require("obsidian");

// src/view/components/obsidian/obsidianMarkdown.svelte
var import_obsidian7 = require("obsidian");
function create_fragment6(ctx) {
  let div;
  let ObsidianMarkdownRender_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = ``;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = action_destroyer(ObsidianMarkdownRender_action = ObsidianMarkdownRender.call(null, div, {
          app: (
            /*app*/
            ctx[0]
          ),
          markdown: (
            /*markdown*/
            ctx[2]
          ),
          sourcePath: (
            /*sourcePath*/
            ctx[3]
          ),
          component: (
            /*component*/
            ctx[1]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ObsidianMarkdownRender_action && is_function(ObsidianMarkdownRender_action.update) && dirty & /*app, markdown, sourcePath, component*/
      15)
        ObsidianMarkdownRender_action.update.call(null, {
          app: (
            /*app*/
            ctx2[0]
          ),
          markdown: (
            /*markdown*/
            ctx2[2]
          ),
          sourcePath: (
            /*sourcePath*/
            ctx2[3]
          ),
          component: (
            /*component*/
            ctx2[1]
          )
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { app } = $$props;
  let { component } = $$props;
  let { markdown } = $$props;
  let { sourcePath } = $$props;
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2)
      $$invalidate(0, app = $$props2.app);
    if ("component" in $$props2)
      $$invalidate(1, component = $$props2.component);
    if ("markdown" in $$props2)
      $$invalidate(2, markdown = $$props2.markdown);
    if ("sourcePath" in $$props2)
      $$invalidate(3, sourcePath = $$props2.sourcePath);
  };
  return [app, component, markdown, sourcePath];
}
var ObsidianMarkdown = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment6, safe_not_equal, {
      app: 0,
      component: 1,
      markdown: 2,
      sourcePath: 3
    });
  }
};
var obsidianMarkdown_default = ObsidianMarkdown;

// src/view/components/Card.svelte
var import_lodash = __toESM(require_lodash());
function add_css3(target) {
  append_styles(target, "svelte-we40ei", ".fullContent.svelte-we40ei,.fewContent.svelte-we40ei{border:2px solid;border-radius:15px;padding:10px}.fewContent.svelte-we40ei{overflow:hidden}.fullContent.svelte-we40ei{overflow:scroll}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  child_ctx[2] = i;
  return child_ctx;
}
function create_if_block_2(ctx) {
  let h2;
  let t1;
  let h6;
  let t3;
  let if_block_anchor;
  let if_block = (
    /*fileMatch*/
    ctx[5].file.parent && /*fileMatch*/
    ctx[5].file.parent.path !== "/" && create_if_block_3(ctx)
  );
  return {
    c() {
      h2 = element("h2");
      h2.textContent = `${/*fileMatch*/
      ctx[5].file.basename}`;
      t1 = space();
      h6 = element("h6");
      h6.textContent = `${/*fileMatch*/
      ctx[5].file.extension !== "md" ? (
        /*fileMatch*/
        ctx[5].file.extension
      ) : ""}`;
      t3 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(h6, "class", "nav-file-tag");
      set_style(h6, "font-size", "12px");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, t1, anchor);
      insert(target, h6, anchor);
      insert(target, t3, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*fileMatch*/
        ctx2[5].file.parent && /*fileMatch*/
        ctx2[5].file.parent.path !== "/"
      )
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching) {
        detach(h2);
        detach(t1);
        detach(h6);
        detach(t3);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let strong;
  return {
    c() {
      var _a;
      strong = element("strong");
      strong.textContent = `${/*fileMatch*/
      (_a = ctx[5].file.parent) == null ? void 0 : _a.path}`;
    },
    m(target, anchor) {
      insert(target, strong, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(strong);
      }
    }
  };
}
function create_else_block(ctx) {
  let obsidianmarkdown;
  let current;
  obsidianmarkdown = new obsidianMarkdown_default({
    props: {
      app: (
        /*app*/
        ctx[6]
      ),
      component: (
        /*component*/
        ctx[0]
      ),
      sourcePath: (
        /*fileMatch*/
        ctx[5].file.path
      ),
      markdown: (
        /*cont*/
        ctx[21].content
      )
    }
  });
  return {
    c() {
      create_component(obsidianmarkdown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(obsidianmarkdown, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const obsidianmarkdown_changes = {};
      if (dirty & /*component*/
      1)
        obsidianmarkdown_changes.component = /*component*/
        ctx2[0];
      if (dirty & /*onHover, contents*/
      24)
        obsidianmarkdown_changes.markdown = /*cont*/
        ctx2[21].content;
      obsidianmarkdown.$set(obsidianmarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(obsidianmarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(obsidianmarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(obsidianmarkdown, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  let obsidianmarkdown;
  let current;
  let mounted;
  let dispose;
  obsidianmarkdown = new obsidianMarkdown_default({
    props: {
      app: (
        /*app*/
        ctx[6]
      ),
      component: (
        /*component*/
        ctx[0]
      ),
      sourcePath: (
        /*fileMatch*/
        ctx[5].file.path
      ),
      markdown: (
        /*cont*/
        ctx[21].content
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(obsidianmarkdown.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(obsidianmarkdown, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", function() {
          if (is_function((0, import_lodash.curryRight)(
            /*openFileOnMatch*/
            ctx[8]
          )(
            /*cont*/
            ctx[21].matches
          )))
            (0, import_lodash.curryRight)(
              /*openFileOnMatch*/
              ctx[8]
            )(
              /*cont*/
              ctx[21].matches
            ).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const obsidianmarkdown_changes = {};
      if (dirty & /*component*/
      1)
        obsidianmarkdown_changes.component = /*component*/
        ctx[0];
      if (dirty & /*onHover, contents*/
      24)
        obsidianmarkdown_changes.markdown = /*cont*/
        ctx[21].content;
      obsidianmarkdown.$set(obsidianmarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(obsidianmarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(obsidianmarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(obsidianmarkdown);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block2(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*cont*/
      ctx2[21].matches && /*cont*/
      ctx2[21].matches.length !== 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block2(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_fragment7(ctx) {
  var _a;
  let div;
  let t0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div_class_value;
  let div_style_value;
  let div_draggable_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*fileMatch*/
    ((_a = ctx[5]) == null ? void 0 : _a.file) && create_if_block_2(ctx)
  );
  let each_value = ensure_array_like(
    /*onHover*/
    ctx[4] ? (
      /*contents*/
      ctx[3]
    ) : (0, import_lodash.take)(
      /*contents*/
      ctx[3],
      showContentCounts
    )
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[2]
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  let if_block1 = (
    /*contents*/
    ctx[3].length > showContentCounts && !/*onHover*/
    ctx[4] && create_if_block2(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", div_class_value = null_to_empty(
        /*onHover*/
        ctx[4] ? "fullContent" : "fewContent"
      ) + " svelte-we40ei");
      attr(div, "style", div_style_value = styleString(
        /*cellStyle*/
        ctx[1]
      ));
      attr(div, "draggable", div_draggable_value = true);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mouseenter",
            /*mouseenter_handler*/
            ctx[14]
          ),
          listen(
            div,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[15]
          ),
          listen(
            div,
            "contextmenu",
            /*moveFileToTrashFolder*/
            ctx[7]
          ),
          listen(
            div,
            "dragstart",
            /*dragCard*/
            ctx[10]
          ),
          listen(
            div,
            "dragend",
            /*reset*/
            ctx[11]
          ),
          listen(
            div,
            "click",
            /*onOpenFile*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (
        /*fileMatch*/
        (_a2 = ctx2[5]) == null ? void 0 : _a2.file
      )
        if_block0.p(ctx2, dirty);
      if (dirty & /*openFileOnMatch, onHover, contents, showContentCounts, app, component, fileMatch*/
      377) {
        each_value = ensure_array_like(
          /*onHover*/
          ctx2[4] ? (
            /*contents*/
            ctx2[3]
          ) : (0, import_lodash.take)(
            /*contents*/
            ctx2[3],
            showContentCounts
          )
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block2, t1, get_each_context2);
        check_outros();
      }
      if (
        /*contents*/
        ctx2[3].length > showContentCounts && !/*onHover*/
        ctx2[4]
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*onHover*/
      16 && div_class_value !== (div_class_value = null_to_empty(
        /*onHover*/
        ctx2[4] ? "fullContent" : "fewContent"
      ) + " svelte-we40ei")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty & /*cellStyle*/
      2 && div_style_value !== (div_style_value = styleString(
        /*cellStyle*/
        ctx2[1]
      ))) {
        attr(div, "style", div_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
var extendMatchRange = (result, cache) => {
  var _a;
  return (_a = result === null || result === void 0 ? void 0 : result.matches.map((match) => {
    var _a2, _b, _c;
    const matchInternalLink = (_b = (_a2 = cache === null || cache === void 0 ? void 0 : cache.embeds) === null || _a2 === void 0 ? void 0 : _a2.map(getCacheOffset).find(Touch(match))) !== null && _b !== void 0 ? _b : (_c = cache === null || cache === void 0 ? void 0 : cache.links) === null || _c === void 0 ? void 0 : _c.map(getCacheOffset).find(Touch(match));
    return matchInternalLink ? [
      Math.min(matchInternalLink[0], match[0]),
      Math.max(matchInternalLink[1], match[1])
    ] : match;
  })) !== null && _a !== void 0 ? _a : [];
};
var showContentCounts = 3;
function instance5($$self, $$props, $$invalidate) {
  let { view } = $$props;
  let { component } = $$props;
  let { files } = $$props;
  let { index } = $$props;
  let { cellStyle } = $$props;
  let fileMatch = files[index];
  let app = view.app;
  let data;
  let contents = [];
  let onHover = false;
  let listener;
  let dragSymbol;
  const moveFileToTrashFolder = (e) => {
    const mn = new import_obsidian8.Menu().addItem((item) => {
      item.setIcon("trash-2").setTitle("delete file").onClick((c) => {
        view.app.vault.trash(fileMatch.file, false);
      });
    });
    mn.showAtMouseEvent(e);
  };
  const parsing = (data2) => {
    var _a;
    if (data2) {
      const cache = app.metadataCache.getFileCache(fileMatch.file);
      const matches = (0, import_lodash.uniqWith)(extendMatchRange(fileMatch.match, cache), (a, b) => Touch(a)(b));
      return (_a = cache === null || cache === void 0 ? void 0 : cache.sections) === null || _a === void 0 ? void 0 : _a.map((section) => {
        const sectionPostion = getCacheOffset(section);
        const [start, end] = sectionPostion;
        const matchInSection = matches.filter(InRange(sectionPostion));
        const sectionContent = data2.substring(start, end);
        const offset = start;
        if (section.type === "code" /* code */) {
          return {
            content: sectionContent,
            matches: matchInSection,
            cache: section,
            offset
          };
        }
        const highlightParsing = matchInSection.reduce(
          (prev, match) => {
            const [prevContent, prevEnd] = prev;
            const [matchStart, matchEnd] = [match[0] - offset, match[1] - offset];
            const prevSection = sectionContent.substring(prevEnd, matchStart);
            const highlightMatch = `==${sectionContent.substring(matchStart, matchEnd)}==`;
            return [prevContent + prevSection + highlightMatch, matchEnd];
          },
          ["", 0]
        );
        const [highlightContensts, parseEnd] = highlightParsing;
        return {
          content: parseEnd <= end ? highlightContensts + sectionContent.substring(parseEnd, end) : highlightContensts,
          matches: matchInSection,
          cache: section
        };
      });
    }
  };
  const openFileOnMatch = (e, matches) => {
    if (e.target instanceof HTMLAnchorElement) {
      return;
    }
    if (matches) {
      view.plugin.onClickOpenFile(e, fileMatch.file, {
        eState: {
          match: {
            content: data !== null && data !== void 0 ? data : "",
            matches
          }
        }
      });
      e.stopPropagation();
    }
  };
  const onOpenFile = (e) => {
    const target = e.target;
    if (target instanceof HTMLAnchorElement) {
      if (target.classList.contains("internal-link")) {
        const linktext = target.getAttribute("data-href");
        if (linktext) {
          view.app.workspace.openLinkText(linktext, fileMatch.file.path);
        }
      }
      return;
    } else {
      view.plugin.onClickOpenFile(e, fileMatch.file);
    }
  };
  const setContent = () => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const content = validCacheReadFilesExtension.contains(fileMatch.file.extension) ? fileMatch.content ? Promise.resolve(fileMatch.content) : app.vault.cachedRead(fileMatch.file) : Promise.resolve(fileMatch.content);
    data = yield content;
    $$invalidate(3, contents = (_a = parsing(data)) !== null && _a !== void 0 ? _a : [
      {
        content: app.fileManager.generateMarkdownLink(fileMatch.file, "")
      }
    ]);
  });
  const dragCard = (dragStart) => {
    var _a;
    const createFileInView = (drop) => {
      var _a2, _b;
      const drawView = view.plugin.getDropView(drop);
      if (isObsidianCanvasView(drawView)) {
        const pos = drawView.canvas.posFromEvt(drop);
        drawView.canvas.createFileNode({ file: fileMatch.file, pos, save: true });
      }
      if (isExcalidrawView(drawView)) {
        const link = view.app.fileManager.generateMarkdownLink(fileMatch.file, (_b = (_a2 = drawView.file) === null || _a2 === void 0 ? void 0 : _a2.path) !== null && _b !== void 0 ? _b : "");
        insertEmbeddableOnDrawing(drop, drawView, link, fileMatch.file, view.plugin);
      }
    };
    const img = new Image();
    (0, import_obsidian8.setIcon)(img, "file-text");
    dragSymbol = view.containerEl.createDiv();
    const icon = dragSymbol.createDiv(), filInfoEl = dragSymbol.createSpan();
    icon.style.display = "inline-block";
    (0, import_obsidian8.setIcon)(icon, "file-text");
    filInfoEl.textContent = " " + fileMatch.file.path;
    dragSymbol.setCssStyles({
      position: "absolute",
      transform: "translate(-1000px,-1000px)"
    });
    (_a = dragStart.dataTransfer) === null || _a === void 0 ? void 0 : _a.setDragImage(dragSymbol, 0, 30);
    setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
      listener = view.plugin.listenDragAndDrop(dragStart, data !== null && data !== void 0 ? data : "", createFileInView);
    }));
  };
  const reset = (dragEnd) => {
    listener.reset();
    view.containerEl.removeChild(dragSymbol);
  };
  onMount(() => {
    setContent();
  });
  const mouseenter_handler = (e) => $$invalidate(4, onHover = true);
  const mouseleave_handler = (e) => $$invalidate(4, onHover = false);
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(12, view = $$props2.view);
    if ("component" in $$props2)
      $$invalidate(0, component = $$props2.component);
    if ("files" in $$props2)
      $$invalidate(13, files = $$props2.files);
    if ("index" in $$props2)
      $$invalidate(2, index = $$props2.index);
    if ("cellStyle" in $$props2)
      $$invalidate(1, cellStyle = $$props2.cellStyle);
  };
  return [
    component,
    cellStyle,
    index,
    contents,
    onHover,
    fileMatch,
    app,
    moveFileToTrashFolder,
    openFileOnMatch,
    onOpenFile,
    dragCard,
    reset,
    view,
    files,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Card = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance5,
      create_fragment7,
      safe_not_equal,
      {
        view: 12,
        component: 0,
        files: 13,
        index: 2,
        cellStyle: 1
      },
      add_css3
    );
  }
};
var Card_default = Card;

// src/view/Index.svelte
var get_default_slot_changes5 = (dirty) => ({ item: dirty & /*items*/
1 });
var get_default_slot_context5 = (ctx) => ({
  item: (
    /*items*/
    ctx[0].map(
      /*func*/
      ctx[5]
    )
  )
});
function create_fragment8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_default_slot_context5
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, items*/
        9)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { items } = $$props;
  let { columnCount } = $$props;
  const computeIndex = (item) => {
    const dataBefore = item.rowIndex * columnCount, columOffest = item.columnIndex, dataIndex = dataBefore + columOffest;
    return dataIndex;
  };
  const func = (it) => ({ ...it, index: computeIndex(it) });
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("columnCount" in $$props2)
      $$invalidate(2, columnCount = $$props2.columnCount);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [items, computeIndex, columnCount, $$scope, slots, func];
}
var Index = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment8, safe_not_equal, { items: 0, columnCount: 2 });
  }
};
var Index_default = Index;

// src/view/components/searchInput.svelte
var import_obsidian11 = require("obsidian");

// src/view/components/obsidian/useComponent.ts
var import_obsidian10 = require("obsidian");
var obsidianSearch = (ele, use) => {
  use(new import_obsidian10.SearchComponent(ele));
};
var obsdianToggleButton = (ele, use) => {
  const button = new import_obsidian10.ButtonComponent(ele);
  use.toggle() && button.setCta();
  ele.onClickEvent(() => {
    if (use.toggle()) {
      button.setCta();
    } else {
      button.removeCta();
    }
  });
  use.buttonSetting(button);
};
var obsidianText = (ele, use) => {
  use(new import_obsidian10.TextComponent(ele));
};

// src/view/components/searchInput.svelte
function add_css4(target) {
  append_styles(target, "svelte-ophvyk", ".searchBar.svelte-ophvyk{border-width:0px;display:flex;justify-content:space-around;outline-width:1px}");
}
function create_if_block3(ctx) {
  let div0;
  let t1;
  let div1;
  let obsidianText_action;
  let t2;
  let div2;
  let t4;
  let div3;
  let obsidianText_action_1;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      div0.textContent = "files to include";
      t1 = space();
      div1 = element("div");
      t2 = space();
      div2 = element("div");
      div2.textContent = "files to exclude";
      t4 = space();
      div3 = element("div");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      insert(target, t2, anchor);
      insert(target, div2, anchor);
      insert(target, t4, anchor);
      insert(target, div3, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(obsidianText_action = obsidianText.call(
            null,
            div1,
            /*includeText*/
            ctx[9]
          )),
          action_destroyer(obsidianText_action_1 = obsidianText.call(
            null,
            div3,
            /*excludeText*/
            ctx[10]
          ))
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(div1);
        detach(t2);
        detach(div2);
        detach(t4);
        detach(div3);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment9(ctx) {
  let div4;
  let div0;
  let obsidianSearch_action;
  let t0;
  let div3;
  let div1;
  let obsidianToggleButton_action;
  let t1;
  let div2;
  let obsidianToggleButton_action_1;
  let t2;
  let div5;
  let obsidianToggleButton_action_2;
  let t3;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = (
    /*$settings*/
    ctx[4].showSearchDetail && create_if_block3(ctx)
  );
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      t2 = space();
      div5 = element("div");
      t3 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      set_style(div0, "width", `100%`);
      set_style(div3, "position", `absolute`);
      set_style(div3, "inset-inline-end", `50px`);
      set_style(div3, "display", `flex`);
      attr(div4, "class", "searchBar svelte-ophvyk");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      append(div3, t1);
      append(div3, div2);
      insert(target, t2, anchor);
      insert(target, div5, anchor);
      insert(target, t3, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(obsidianSearch_action = obsidianSearch.call(
            null,
            div0,
            /*bindInput*/
            ctx[5]
          )),
          action_destroyer(obsidianToggleButton_action = obsdianToggleButton.call(null, div1, {
            buttonSetting: (
              /*matchCaseButton*/
              ctx[7]
            ),
            toggle: (
              /*obsidianToggleButton_function*/
              ctx[12]
            )
          })),
          action_destroyer(obsidianToggleButton_action_1 = obsdianToggleButton.call(null, div2, {
            buttonSetting: (
              /*regexButton*/
              ctx[6]
            ),
            toggle: (
              /*obsidianToggleButton_function_1*/
              ctx[13]
            )
          })),
          action_destroyer(obsidianToggleButton_action_2 = obsdianToggleButton.call(null, div5, {
            buttonSetting: (
              /*showSearchDetail*/
              ctx[8]
            ),
            toggle: (
              /*obsidianToggleButton_function_2*/
              ctx[14]
            )
          }))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (obsidianToggleButton_action && is_function(obsidianToggleButton_action.update) && dirty & /*$settings*/
      16)
        obsidianToggleButton_action.update.call(null, {
          buttonSetting: (
            /*matchCaseButton*/
            ctx2[7]
          ),
          toggle: (
            /*obsidianToggleButton_function*/
            ctx2[12]
          )
        });
      if (obsidianToggleButton_action_1 && is_function(obsidianToggleButton_action_1.update) && dirty & /*$settings*/
      16)
        obsidianToggleButton_action_1.update.call(null, {
          buttonSetting: (
            /*regexButton*/
            ctx2[6]
          ),
          toggle: (
            /*obsidianToggleButton_function_1*/
            ctx2[13]
          )
        });
      if (obsidianToggleButton_action_2 && is_function(obsidianToggleButton_action_2.update) && dirty & /*$settings*/
      16)
        obsidianToggleButton_action_2.update.call(null, {
          buttonSetting: (
            /*showSearchDetail*/
            ctx2[8]
          ),
          toggle: (
            /*obsidianToggleButton_function_2*/
            ctx2[14]
          )
        });
      if (
        /*$settings*/
        ctx2[4].showSearchDetail
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div4);
        detach(t2);
        detach(div5);
        detach(t3);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let $exclude, $$unsubscribe_exclude = noop, $$subscribe_exclude = () => ($$unsubscribe_exclude(), $$unsubscribe_exclude = subscribe(exclude, ($$value) => $$invalidate(15, $exclude = $$value)), exclude);
  let $include, $$unsubscribe_include = noop, $$subscribe_include = () => ($$unsubscribe_include(), $$unsubscribe_include = subscribe(include, ($$value) => $$invalidate(16, $include = $$value)), include);
  let $settings, $$unsubscribe_settings = noop, $$subscribe_settings = () => ($$unsubscribe_settings(), $$unsubscribe_settings = subscribe(settings, ($$value) => $$invalidate(4, $settings = $$value)), settings);
  let $query, $$unsubscribe_query = noop, $$subscribe_query = () => ($$unsubscribe_query(), $$unsubscribe_query = subscribe(query, ($$value) => $$invalidate(17, $query = $$value)), query);
  $$self.$$.on_destroy.push(() => $$unsubscribe_exclude());
  $$self.$$.on_destroy.push(() => $$unsubscribe_include());
  $$self.$$.on_destroy.push(() => $$unsubscribe_settings());
  $$self.$$.on_destroy.push(() => $$unsubscribe_query());
  let { query } = $$props;
  $$subscribe_query();
  let { debounceTime = 0 } = $$props;
  let { include = writable("") } = $$props;
  $$subscribe_include();
  let { exclude = writable("") } = $$props;
  $$subscribe_exclude();
  let { settings } = $$props;
  $$subscribe_settings();
  const bindInput = (comp) => {
    comp.setValue($query).onChange((0, import_obsidian11.debounce)(
      (text2) => {
        set_store_value(query, $query = text2, $query);
      },
      debounceTime
    ));
  };
  const regexButton = (comp) => {
    comp.setIcon("regex").setTooltip("Use Regular Expression").onClick((e) => {
      set_store_value(settings, $settings.useRegex = !$settings.useRegex, $settings);
    });
  };
  const matchCaseButton = (comp) => {
    comp.setIcon("case-sensitive").setTooltip("Match Case").onClick((e) => {
      set_store_value(settings, $settings.matchCase = !$settings.matchCase, $settings);
    });
  };
  const showSearchDetail = (button) => {
    button.setButtonText("...").setTooltip("Toggle Search Detail").onClick(() => {
      set_store_value(settings, $settings.showSearchDetail = !$settings.showSearchDetail, $settings);
    });
  };
  const setTexInputStyle = (inputEl) => {
    inputEl.setCssStyles({ width: "100%" });
  };
  const includeText = (comp) => {
    setTexInputStyle(comp.setValue($include).onChange((0, import_obsidian11.debounce)(
      (text2) => {
        set_store_value(include, $include = text2, $include);
      },
      debounceTime
    )).setPlaceholder("e.g. .*\\.md").inputEl);
  };
  const excludeText = (comp) => {
    setTexInputStyle(comp.setValue($exclude).onChange((0, import_obsidian11.debounce)(
      (text2) => {
        set_store_value(exclude, $exclude = text2, $exclude);
      },
      debounceTime
    )).setPlaceholder("e.g. .*\\.png").inputEl);
  };
  const obsidianToggleButton_function = () => $settings.matchCase;
  const obsidianToggleButton_function_1 = () => $settings.useRegex;
  const obsidianToggleButton_function_2 = () => $settings.showSearchDetail;
  $$self.$$set = ($$props2) => {
    if ("query" in $$props2)
      $$subscribe_query($$invalidate(0, query = $$props2.query));
    if ("debounceTime" in $$props2)
      $$invalidate(11, debounceTime = $$props2.debounceTime);
    if ("include" in $$props2)
      $$subscribe_include($$invalidate(1, include = $$props2.include));
    if ("exclude" in $$props2)
      $$subscribe_exclude($$invalidate(2, exclude = $$props2.exclude));
    if ("settings" in $$props2)
      $$subscribe_settings($$invalidate(3, settings = $$props2.settings));
  };
  return [
    query,
    include,
    exclude,
    settings,
    $settings,
    bindInput,
    regexButton,
    matchCaseButton,
    showSearchDetail,
    includeText,
    excludeText,
    debounceTime,
    obsidianToggleButton_function,
    obsidianToggleButton_function_1,
    obsidianToggleButton_function_2
  ];
}
var SearchInput = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance7,
      create_fragment9,
      safe_not_equal,
      {
        query: 0,
        debounceTime: 11,
        include: 1,
        exclude: 2,
        settings: 3
      },
      add_css4
    );
  }
};
var searchInput_default = SearchInput;

// src/view/components/Search.svelte
function add_css5(target) {
  append_styles(target, "svelte-aa25ck", ".searchMenuBar.svelte-aa25ck{display:flex;align-items:end}.searchMenuBar.svelte-aa25ck{justify-content:space-between}.buttonBar.svelte-aa25ck{display:flex;align-items:center;justify-content:space-evenly;gap:3px}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let div2;
  let div0;
  let columnWidthSetting_action;
  let t1;
  let div1;
  let rowHeightSetting_action;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      div0.textContent = "column width";
      t1 = space();
      div1 = element("div");
      div1.textContent = "row height";
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
      if (!mounted) {
        dispose = [
          action_destroyer(columnWidthSetting_action = /*columnWidthSetting*/
          ctx[20].call(null, div0)),
          action_destroyer(rowHeightSetting_action = /*rowHeightSetting*/
          ctx[21].call(null, div1))
        ];
        mounted = true;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block4(ctx) {
  let card;
  let current;
  card = new Card_default({
    props: {
      view: (
        /*view*/
        ctx[0]
      ),
      cellStyle: (
        /*computeGapStyle*/
        ctx[24](
          /*cell*/
          ctx[41].style,
          /*gridProps*/
          ctx[38].padding
        )
      ),
      component: (
        /*view*/
        ctx[0]
      ),
      files: (
        /*$filesDisplay*/
        ctx[6]
      ),
      index: (
        /*cell*/
        ctx[41].index
      )
    }
  });
  return {
    c() {
      create_component(card.$$.fragment);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const card_changes = {};
      if (dirty[0] & /*view*/
      1)
        card_changes.view = /*view*/
        ctx2[0];
      if (dirty[1] & /*cells, gridProps*/
      640)
        card_changes.cellStyle = /*computeGapStyle*/
        ctx2[24](
          /*cell*/
          ctx2[41].style,
          /*gridProps*/
          ctx2[38].padding
        );
      if (dirty[0] & /*view*/
      1)
        card_changes.component = /*view*/
        ctx2[0];
      if (dirty[0] & /*$filesDisplay*/
      64)
        card_changes.files = /*$filesDisplay*/
        ctx2[6];
      if (dirty[1] & /*cells*/
      512)
        card_changes.index = /*cell*/
        ctx2[41].index;
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function create_each_block3(key_1, ctx) {
  let first;
  let if_block_anchor;
  let current;
  let if_block = (
    /*cell*/
    ctx[41].index < /*$filesDisplay*/
    ctx[6].length && create_if_block4(ctx)
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*cell*/
        ctx[41].index < /*$filesDisplay*/
        ctx[6].length
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*$filesDisplay*/
          64 | dirty[1] & /*cells*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*cells*/
    ctx[40]
  );
  const get_key = (ctx2) => (
    /*computeKey*/
    ctx2[18](
      /*cell*/
      ctx2[41].index
    )
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*view, computeGapStyle, $filesDisplay*/
      16777281 | dirty[1] & /*cells, gridProps*/
      640) {
        each_value = ensure_array_like(
          /*cells*/
          ctx2[40]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block3, each_1_anchor, get_each_context3);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
}
function create_default_slot_2(ctx) {
  let index;
  let current;
  index = new Index_default({
    props: {
      items: (
        /*items*/
        ctx[39]
      ),
      columnCount: (
        /*gridProps*/
        ctx[38].columns
      ),
      $$slots: {
        default: [
          create_default_slot_3,
          ({ item: cells }) => ({ 40: cells }),
          ({ item: cells }) => [0, cells ? 512 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(index.$$.fragment);
    },
    m(target, anchor) {
      mount_component(index, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const index_changes = {};
      if (dirty[1] & /*items*/
      256)
        index_changes.items = /*items*/
        ctx2[39];
      if (dirty[1] & /*gridProps*/
      128)
        index_changes.columnCount = /*gridProps*/
        ctx2[38].columns;
      if (dirty[0] & /*view, $filesDisplay*/
      65 | dirty[1] & /*$$scope, cells, gridProps*/
      8832) {
        index_changes.$$scope = { dirty, ctx: ctx2 };
      }
      index.$set(index_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(index.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(index.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(index, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  var _a, _b;
  let grid_1;
  let current;
  let grid_1_props = {
    initialScrollTop: (
      /*offset*/
      ctx[4].scrollTop
    ),
    columnCount: (
      /*gridProps*/
      ctx[38].columns
    ),
    columnWidth: (
      /*columnWidth*/
      ctx[1] + gutter2
    ),
    height: (
      /*childHeight*/
      (_a = ctx[37]) != null ? _a : 500
    ),
    rowCount: (
      /*gridProps*/
      ctx[38].rows
    ),
    rowHeight: (
      /*rowHeight*/
      ctx[2] + gutter2
    ),
    width: (
      /*childWidth*/
      (_b = ctx[36]) != null ? _b : 500
    ),
    onScroll: (
      /*rememberScrollOffsetForFileUpdate*/
      ctx[25]
    ),
    $$slots: {
      default: [
        create_default_slot_2,
        ({ items }) => ({ 39: items }),
        ({ items }) => [0, items ? 256 : 0]
      ]
    },
    $$scope: { ctx }
  };
  grid_1 = new FixedSizeGrid_default2({ props: grid_1_props });
  ctx[28](grid_1);
  return {
    c() {
      create_component(grid_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(grid_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const grid_1_changes = {};
      if (dirty[0] & /*offset*/
      16)
        grid_1_changes.initialScrollTop = /*offset*/
        ctx2[4].scrollTop;
      if (dirty[1] & /*gridProps*/
      128)
        grid_1_changes.columnCount = /*gridProps*/
        ctx2[38].columns;
      if (dirty[0] & /*columnWidth*/
      2)
        grid_1_changes.columnWidth = /*columnWidth*/
        ctx2[1] + gutter2;
      if (dirty[1] & /*childHeight*/
      64)
        grid_1_changes.height = /*childHeight*/
        (_a2 = ctx2[37]) != null ? _a2 : 500;
      if (dirty[1] & /*gridProps*/
      128)
        grid_1_changes.rowCount = /*gridProps*/
        ctx2[38].rows;
      if (dirty[0] & /*rowHeight*/
      4)
        grid_1_changes.rowHeight = /*rowHeight*/
        ctx2[2] + gutter2;
      if (dirty[1] & /*childWidth*/
      32)
        grid_1_changes.width = /*childWidth*/
        (_b2 = ctx2[36]) != null ? _b2 : 500;
      if (dirty[0] & /*view, $filesDisplay*/
      65 | dirty[1] & /*$$scope, items, gridProps*/
      8576) {
        grid_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      grid_1.$set(grid_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(grid_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(grid_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[28](null);
      destroy_component(grid_1, detaching);
    }
  };
}
function create_default_slot2(ctx) {
  var _a, _b;
  let computelayout;
  let current;
  computelayout = new ComputeLayout_default({
    props: {
      viewHeight: (
        /*childHeight*/
        (_a = ctx[37]) != null ? _a : 1e3
      ),
      viewWidth: (
        /*childWidth*/
        (_b = ctx[36]) != null ? _b : 1e3
      ),
      columnWidth: (
        /*columnWidth*/
        ctx[1]
      ),
      gap: gutter2,
      totalCount: (
        /*$filesDisplay*/
        ctx[6].length
      ),
      $$slots: {
        default: [
          create_default_slot_1,
          ({ gridProps }) => ({ 38: gridProps }),
          ({ gridProps }) => [0, gridProps ? 128 : 0]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(computelayout.$$.fragment);
    },
    m(target, anchor) {
      mount_component(computelayout, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      const computelayout_changes = {};
      if (dirty[1] & /*childHeight*/
      64)
        computelayout_changes.viewHeight = /*childHeight*/
        (_a2 = ctx2[37]) != null ? _a2 : 1e3;
      if (dirty[1] & /*childWidth*/
      32)
        computelayout_changes.viewWidth = /*childWidth*/
        (_b2 = ctx2[36]) != null ? _b2 : 1e3;
      if (dirty[0] & /*columnWidth*/
      2)
        computelayout_changes.columnWidth = /*columnWidth*/
        ctx2[1];
      if (dirty[0] & /*$filesDisplay*/
      64)
        computelayout_changes.totalCount = /*$filesDisplay*/
        ctx2[6].length;
      if (dirty[0] & /*offset, columnWidth, rowHeight, grid, view, $filesDisplay*/
      119 | dirty[1] & /*$$scope, gridProps, childHeight, childWidth*/
      8416) {
        computelayout_changes.$$scope = { dirty, ctx: ctx2 };
      }
      computelayout.$set(computelayout_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(computelayout.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(computelayout.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(computelayout, detaching);
    }
  };
}
function create_fragment10(ctx) {
  let searchinput;
  let t0;
  let div3;
  let div0;
  let t1_value = (
    /*$filesDisplay*/
    ctx[6].length + ""
  );
  let t1;
  let t2;
  let t3;
  let div2;
  let t4;
  let div1;
  let layoutSetting_action;
  let t5;
  let buttongroups0;
  let t6;
  let buttongroups1;
  let t7;
  let autosizer;
  let current;
  let mounted;
  let dispose;
  searchinput = new searchInput_default({
    props: {
      query: (
        /*queryNew*/
        ctx[11]
      ),
      include: (
        /*include*/
        ctx[12]
      ),
      exclude: (
        /*exclude*/
        ctx[13]
      ),
      settings: (
        /*searchSettings*/
        ctx[10]
      ),
      debounceTime: 700
    }
  });
  let if_block = (
    /*showLayoutMenu*/
    ctx[3] && create_if_block_12(ctx)
  );
  buttongroups0 = new ButtonGroups_default({
    props: {
      buttons: (
        /*sortMethods*/
        ctx[23]
      ),
      onclick: (
        /*func*/
        ctx[26]
      )
    }
  });
  buttongroups1 = new ButtonGroups_default({
    props: {
      buttons: (
        /*sortSeq*/
        ctx[22]
      ),
      onclick: (
        /*func_1*/
        ctx[27]
      )
    }
  });
  autosizer = new svelte_virtualized_auto_sizer_default({
    props: {
      $$slots: {
        default: [
          create_default_slot2,
          ({ width: childWidth, height: childHeight }) => ({ 36: childWidth, 37: childHeight }),
          ({ width: childWidth, height: childHeight }) => [0, (childWidth ? 32 : 0) | (childHeight ? 64 : 0)]
        ]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(searchinput.$$.fragment);
      t0 = space();
      div3 = element("div");
      div0 = element("div");
      t1 = text(t1_value);
      t2 = text(" results");
      t3 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t4 = space();
      div1 = element("div");
      t5 = space();
      create_component(buttongroups0.$$.fragment);
      t6 = space();
      create_component(buttongroups1.$$.fragment);
      t7 = space();
      create_component(autosizer.$$.fragment);
      attr(div2, "class", "buttonBar svelte-aa25ck");
      attr(div3, "class", "searchMenuBar svelte-aa25ck");
    },
    m(target, anchor) {
      mount_component(searchinput, target, anchor);
      insert(target, t0, anchor);
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, t1);
      append(div0, t2);
      append(div3, t3);
      append(div3, div2);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t4);
      append(div2, div1);
      append(div2, t5);
      mount_component(buttongroups0, div2, null);
      append(div2, t6);
      mount_component(buttongroups1, div2, null);
      insert(target, t7, anchor);
      mount_component(autosizer, target, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(layoutSetting_action = /*layoutSetting*/
        ctx[19].call(null, div1));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*$filesDisplay*/
      64) && t1_value !== (t1_value = /*$filesDisplay*/
      ctx2[6].length + ""))
        set_data(t1, t1_value);
      if (
        /*showLayoutMenu*/
        ctx2[3]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          if_block.m(div2, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const buttongroups0_changes = {};
      if (dirty[0] & /*$sortMethodNew*/
      128)
        buttongroups0_changes.onclick = /*func*/
        ctx2[26];
      buttongroups0.$set(buttongroups0_changes);
      const buttongroups1_changes = {};
      if (dirty[0] & /*$seqNew*/
      256)
        buttongroups1_changes.onclick = /*func_1*/
        ctx2[27];
      buttongroups1.$set(buttongroups1_changes);
      const autosizer_changes = {};
      if (dirty[0] & /*columnWidth, $filesDisplay, offset, rowHeight, grid, view*/
      119 | dirty[1] & /*$$scope, childHeight, childWidth*/
      8288) {
        autosizer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      autosizer.$set(autosizer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(searchinput.$$.fragment, local);
      transition_in(buttongroups0.$$.fragment, local);
      transition_in(buttongroups1.$$.fragment, local);
      transition_in(autosizer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(searchinput.$$.fragment, local);
      transition_out(buttongroups0.$$.fragment, local);
      transition_out(buttongroups1.$$.fragment, local);
      transition_out(autosizer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div3);
        detach(t7);
      }
      destroy_component(searchinput, detaching);
      if (if_block)
        if_block.d();
      destroy_component(buttongroups0);
      destroy_component(buttongroups1);
      destroy_component(autosizer, detaching);
      mounted = false;
      dispose();
    }
  };
}
var gutter2 = 30;
function instance8($$self, $$props, $$invalidate) {
  let $exclude;
  let $include;
  let $searchSettings;
  let $queryNew;
  let $filesNew;
  let $filesDisplay;
  let $searchedFiles;
  let $sortMethodNew;
  let $seqNew;
  let { view } = $$props;
  let columnWidth = view.plugin.settings.columnWidth;
  let rowHeight = view.plugin.settings.rowHeight;
  let showLayoutMenu = false;
  const filesNew = writable([]);
  component_subscribe($$self, filesNew, (value) => $$invalidate(33, $filesNew = value));
  const searchSettings = writable({
    useRegex: view.plugin.settings.useRegex,
    matchCase: view.plugin.settings.matchCase,
    showSearchDetail: view.plugin.settings.showSearchDetail
  });
  component_subscribe($$self, searchSettings, (value) => $$invalidate(31, $searchSettings = value));
  const queryNew = writable(view.plugin.settings.query);
  component_subscribe($$self, queryNew, (value) => $$invalidate(32, $queryNew = value));
  const include = writable(view.plugin.settings.include);
  component_subscribe($$self, include, (value) => $$invalidate(30, $include = value));
  const exclude = writable(view.plugin.settings.exclude);
  component_subscribe($$self, exclude, (value) => $$invalidate(29, $exclude = value));
  const sortMethodNew = writable(sortByModifiedTime);
  component_subscribe($$self, sortMethodNew, (value) => $$invalidate(7, $sortMethodNew = value));
  const seqNew = writable(1 /* descending */);
  component_subscribe($$self, seqNew, (value) => $$invalidate(8, $seqNew = value));
  const filesReadyForSearch = derived([filesNew, include, exclude], ([$files, $include2, $exclude2], set) => {
    const getRemovePattern = () => {
      var _a;
      return (_a = tryCreateRegex($exclude2)) !== null && _a !== void 0 ? _a : { test: (str) => false };
    };
    const getIncludePattern = () => {
      var _a;
      return (_a = tryCreateRegex($include2)) !== null && _a !== void 0 ? _a : { test: (str) => true };
    };
    const includeFiles = $files.filter((file) => {
      const remove = $exclude2.length != 0 && getRemovePattern().test(file.path);
      const need = $include2.length == 0 || getIncludePattern().test(file.path);
      return !remove && need;
    });
    set(includeFiles);
  });
  const searchedFiles = derived(
    [filesReadyForSearch, queryNew, searchSettings],
    ([$files, $query, $setting], set) => {
      const searchMethod = $setting.useRegex ? searchByRegex($query, $setting.matchCase ? "g" : "gi") : search($query);
      const finds = $query.length !== 0 ? Promise.all($files.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        var fileCache = $searchedFiles.find((f) => isSearchedFile(f) && f.file.path === file.path);
        var content = fileCache && fileCache.file.stat.mtime === file.stat.mtime ? Promise.resolve(fileCache.content) : validCacheReadFilesExtension.contains(file.extension) ? view.app.vault.cachedRead(file) : Promise.resolve("");
        const cont = yield content;
        return searchMethod(file, cont !== null && cont !== void 0 ? cont : "");
      }))).then((files) => files.filter((f) => f !== void 0)) : Promise.resolve($files);
      finds.then((data) => set(data));
    },
    []
  );
  component_subscribe($$self, searchedFiles, (value) => $$invalidate(34, $searchedFiles = value));
  const filesDisplay = derived(
    [searchedFiles, sortMethodNew, seqNew],
    ([$files, $sortMethod, $seq], set) => {
      const sortM = $seq === 1 /* descending */ ? (a, b) => -$sortMethod(a, b) : $sortMethod;
      const sortFiles = $files.map((f) => isSearchedFile(f) ? f : { file: f });
      sortFiles.sort(sortM);
      set([...sortFiles]);
    },
    []
  );
  component_subscribe($$self, filesDisplay, (value) => $$invalidate(6, $filesDisplay = value));
  let offset = {
    scrollLeft: 0,
    scrollTop: 0,
    verticalScrollDirection: "forward",
    scrollUpdateWasRequested: false,
    horizontalScrollDirection: "forward"
  };
  const computeKey = (index) => {
    return index < $filesDisplay.length ? index + $filesDisplay[index].file.path + $filesDisplay[index].file.stat.mtime + $queryNew + ($queryNew.length !== 0 ? `${$searchSettings.useRegex}${$searchSettings.matchCase}` : "") : index;
  };
  onMount(() => {
    set_store_value(filesNew, $filesNew = view.app.vault.getFiles(), $filesNew);
    const vault = view.app.vault;
    const registerVaultEvent = (callback) => {
      return (tf) => {
        if (tf instanceof import_obsidian12.TFile) {
          callback(tf);
        }
      };
    };
    const create = view.app.vault.on("create", registerVaultEvent((newF) => {
      set_store_value(filesNew, $filesNew = [...$filesNew, newF], $filesNew);
    }));
    const del = view.app.vault.on("delete", registerVaultEvent((delF) => {
      set_store_value(filesNew, $filesNew = $filesNew.filter((of) => of !== delF), $filesNew);
    }));
    const modify = view.app.vault.on("modify", registerVaultEvent((mf) => __awaiter(void 0, void 0, void 0, function* () {
      set_store_value(filesNew, $filesNew = $filesNew.map((of) => of === mf ? mf : of), $filesNew);
    })));
    const rename = view.app.vault.on("rename", (tf, oldPath) => registerVaultEvent((renameFile) => {
      set_store_value(filesNew, $filesNew = $filesNew.map((old) => old.path === oldPath ? renameFile : old), $filesNew);
    })(tf));
    const leafChange = view.app.workspace.on("active-leaf-change", (leaf) => __awaiter(void 0, void 0, void 0, function* () {
      if ((leaf === null || leaf === void 0 ? void 0 : leaf.view.getViewType()) === view.getViewType() && grid) {
        grid.scrollTo({ scrollLeft: 0, scrollTop: 0 });
        grid.scrollTo({
          scrollLeft: offset.scrollLeft,
          scrollTop: offset.scrollTop
        });
      }
    }));
    return () => {
      vault.offref(create);
      vault.offref(modify);
      vault.offref(del);
      vault.offref(rename);
      view.app.workspace.offref(leafChange);
      $$invalidate(0, view.plugin.settings.query = $queryNew, view);
      $$invalidate(0, view.plugin.settings.useRegex = $searchSettings.useRegex, view);
      $$invalidate(0, view.plugin.settings.matchCase = $searchSettings.matchCase, view);
      $$invalidate(0, view.plugin.settings.showSearchDetail = $searchSettings.showSearchDetail, view);
      $$invalidate(0, view.plugin.settings.include = $include, view);
      $$invalidate(0, view.plugin.settings.exclude = $exclude, view);
      view.plugin.saveSettings();
    };
  });
  const layoutSetting = (ele) => {
    const b = new import_obsidian12.ButtonComponent(ele).setIcon("layout-grid").setTooltip("Toggle Layout Detail").onClick((e) => {
      if (showLayoutMenu) {
        b.removeCta();
      } else {
        b.setCta();
      }
      $$invalidate(3, showLayoutMenu = !showLayoutMenu);
    });
  };
  const columnWidthSetting = (ele) => {
    new import_obsidian12.SliderComponent(ele).setLimits(200, 1e3, 10).setValue(columnWidth).setDynamicTooltip().onChange((value) => {
      $$invalidate(0, view.plugin.settings.columnWidth = value, view);
      view.plugin.saveSettings();
      $$invalidate(1, columnWidth = value);
    });
  };
  const rowHeightSetting = (ele) => {
    new import_obsidian12.SliderComponent(ele).setLimits(200, 1e3, 10).setValue(rowHeight).setDynamicTooltip().onChange((value) => {
      $$invalidate(0, view.plugin.settings.rowHeight = value, view);
      view.plugin.saveSettings();
      $$invalidate(2, rowHeight = value);
    });
  };
  const sortSeq = [
    {
      icon: "arrow-down-narrow-wide",
      toolTip: "asc",
      value: 0 /* ascending */
    },
    {
      icon: "arrow-up-narrow-wide",
      toolTip: "desc",
      value: 1 /* descending */,
      active: true
    }
  ];
  const sortMethods = [
    {
      icon: "file-type-2",
      toolTip: "name",
      value: sortByName
    },
    {
      icon: "file-plus-2",
      toolTip: "last created",
      value: sortByCreateTime
    },
    {
      icon: "file-clock",
      toolTip: "last modified",
      value: sortByModifiedTime,
      active: true
    },
    {
      icon: "file-search",
      toolTip: "related",
      value: sortByRelated
    }
  ];
  const computeGapStyle = (style, padding) => {
    var _a, _b;
    const top = ((_a = style.top) !== null && _a !== void 0 ? _a : 0) + gutter2, left = ((_b = style.left) !== null && _b !== void 0 ? _b : 0) + gutter2 + padding, width = typeof style.width === "number" ? style.width - gutter2 : style.width, height = typeof style.height === "number" ? style.height - gutter2 : style.height;
    return Object.assign(Object.assign({}, style), { top, left, width, height });
  };
  const rememberScrollOffsetForFileUpdate = (0, import_obsidian12.debounce)(
    (props) => {
      $$invalidate(4, offset = props);
    },
    2e3
  );
  let grid;
  const func = (e, value) => {
    set_store_value(sortMethodNew, $sortMethodNew = value, $sortMethodNew);
  };
  const func_1 = (e, value) => {
    set_store_value(seqNew, $seqNew = value, $seqNew);
  };
  function grid_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      grid = $$value;
      $$invalidate(5, grid);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("view" in $$props2)
      $$invalidate(0, view = $$props2.view);
  };
  return [
    view,
    columnWidth,
    rowHeight,
    showLayoutMenu,
    offset,
    grid,
    $filesDisplay,
    $sortMethodNew,
    $seqNew,
    filesNew,
    searchSettings,
    queryNew,
    include,
    exclude,
    sortMethodNew,
    seqNew,
    searchedFiles,
    filesDisplay,
    computeKey,
    layoutSetting,
    columnWidthSetting,
    rowHeightSetting,
    sortSeq,
    sortMethods,
    computeGapStyle,
    rememberScrollOffsetForFileUpdate,
    func,
    func_1,
    grid_1_binding
  ];
}
var Search = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment10, safe_not_equal, { view: 0 }, add_css5, [-1, -1]);
  }
};
var Search_default = Search;

// src/view/cardSearchView.ts
var VIEW_TYPE_CARDNOTESEARCH = "card-notes-view";
var CardSearchView = class extends import_obsidian13.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CARDNOTESEARCH;
  }
  getDisplayText() {
    return "Notes";
  }
  async onOpen() {
    this.component = new Search_default({
      target: this.containerEl.children[1],
      props: {
        view: this
      }
    });
  }
  async onClose() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
  }
};

// src/ui/linkSettings.ts
var import_obsidian14 = require("obsidian");
var LinkSettingModel = class extends import_obsidian14.Modal {
  constructor(plugin, onSubmit) {
    super(plugin.app);
    this.plugin = plugin;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    const setting = new import_obsidian14.Setting(contentEl).setName("Set your label").setDesc("Enter empty could disable adding a label on the link edge automatically").addText((text2) => {
      var _a;
      text2.setValue((_a = this.plugin.settings.defaultLinkLabel) != null ? _a : "");
      text2.onChange((value) => {
        this.label = value.length !== 0 ? value : void 0;
      });
    }).addButton((btn) => {
      btn.setIcon("check").onClick(() => {
        this.onSubmit(this.label);
        this.close();
      }).setCta();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  dragSymbol: "\u{1F494}",
  dragSymbolSize: 18,
  defaultFolder: "",
  columnWidth: 250,
  rowHeight: 250,
  autoLink: false,
  arrowTo: "end",
  query: "string",
  useRegex: false,
  matchCase: false,
  showSearchDetail: false,
  include: "",
  exclude: ""
};
var CardNote = class extends import_obsidian15.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.registerEditorExtension(dragExtension(this));
    this.registerView(
      VIEW_TYPE_CARDNOTESEARCH,
      (leaf) => new CardSearchView(leaf, this)
    );
    this.addRibbonIcon(
      "scan-search",
      "Search Notes",
      () => this.activateView()
    );
    this.addCommands();
    this.addSettingTab(new CardNoteTab(this.app, this));
  }
  addCommands() {
    this.addCommand({
      id: "set-label",
      name: "Set Default Label",
      callback: () => {
        new LinkSettingModel(this, (value) => {
          this.settings.defaultLinkLabel = value;
          this.saveSettings();
        }).open();
      }
    });
    this.addCommand({
      id: "auto-link",
      name: "Enable Auto Link",
      checkCallback: this.changeAutoLinkSettings(
        () => !this.settings.autoLink,
        () => {
          this.settings.autoLink = true;
        }
      )
    });
    this.addCommand({
      id: "cancel-auto-link",
      name: "Disable Auto Link",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.autoLink,
        () => {
          this.settings.autoLink = false;
        }
      )
    });
    this.addCommand({
      id: "arrow-to-from",
      name: "Arrow to From",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.arrowTo !== "from",
        () => {
          this.settings.arrowTo = "from";
        }
      )
    });
    this.addCommand({
      id: "arrow-to-end",
      name: "Arrow to End",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.arrowTo !== "end",
        () => {
          this.settings.arrowTo = "end";
        }
      )
    });
    this.addCommand({
      id: "arrow-to-both",
      name: "Arrow to Both",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.arrowTo !== "both",
        () => {
          this.settings.arrowTo = "both";
        }
      )
    });
    this.addCommand({
      id: "arrow-to-none",
      name: "Arrow to None",
      checkCallback: this.changeAutoLinkSettings(
        () => this.settings.arrowTo !== "none",
        () => {
          this.settings.arrowTo = "none";
        }
      )
    });
  }
  changeAutoLinkSettings(check, action) {
    return (checking) => {
      if (check()) {
        if (!checking) {
          action();
          this.saveSettings();
        }
        return true;
      }
      return false;
    };
  }
  async activateView() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CARDNOTESEARCH), createNewLeaf = async () => {
      const newLeaf = workspace.getLeaf("split");
      await (newLeaf == null ? void 0 : newLeaf.setViewState({
        type: VIEW_TYPE_CARDNOTESEARCH,
        active: true
      }));
      return newLeaf;
    };
    let leaf = leaves.length > 0 ? leaves[0] : await createNewLeaf();
    workspace.revealLeaf(leaf);
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  createPath(file, subpath, displayText) {
    return this.app.metadataCache.fileToLinktext(
      file,
      file.path,
      file.extension === "md"
    );
  }
  createLinkText(file, subpath, displayText) {
    const fileLinkPath = this.createPath(file);
    const sub = subpath != null ? subpath : "";
    const fullLinkPath = `${fileLinkPath}${sub}`;
    const useMarkdownLink = this.app.vault.getConfig("useMarkdownLinks");
    const markdownLink = () => {
      const display = displayText != null ? displayText : fullLinkPath;
      return `[${display}](${fullLinkPath.replace(" ", "%20")})`;
    };
    const wikiLink = () => {
      const display = displayText ? `|${displayText}` : "";
      return `[[${fullLinkPath}${display}]]`;
    };
    const linkText = useMarkdownLink ? markdownLink() : wikiLink();
    return {
      path: fileLinkPath,
      subpath,
      file,
      text: linkText,
      displayText
    };
  }
  getActiveEditorFile() {
    var _a;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian15.TextFileView);
    if (view) {
      if (isObsidianCanvasView(view)) {
        const [selectNode] = view.canvas.selection;
        return isCanvasEditorNode(selectNode) ? { fileEditor: selectNode, offset: getOffset(selectNode) } : void 0;
      }
      if (isExcalidrawView(view)) {
        const excalidrawShape = view.getViewSelectedElements().first();
        const embeddable = view.getActiveEmbeddable();
        return isCanvasEditorNode(embeddable == null ? void 0 : embeddable.node) ? {
          fileEditor: {
            ...embeddable.node,
            id: (_a = excalidrawShape == null ? void 0 : excalidrawShape.id) != null ? _a : embeddable.node.id
          },
          offset: getOffset(embeddable.node)
        } : void 0;
      }
    }
    return { fileEditor: this.app.workspace.activeEditor, offset: 0 };
  }
  async checkFileName(file) {
    const fileName = file.fileName;
    if (fileName.length === 0) {
      return new Error("File Name can not be empty!");
    } else if (fileName.endsWith(" ")) {
      return new Error("File Name can not end with white space!");
    } else {
      const matchInvalidSymbol = FILENAMEREPLACE().exec(fileName);
      if (matchInvalidSymbol) {
        return new Error(`File Name can not contains symbols [!"#$%&()*+,.:;<=>?@^\`{|}~/[]\r
]`);
      }
    }
    const filePathUncheck = createFullPath(file);
    const normalFilePath = (0, import_obsidian15.normalizePath)(filePathUncheck);
    this.app.vault.checkPath(normalFilePath);
    if (await this.app.vault.adapter.exists(normalFilePath)) {
      return new Error("File exist!");
    }
    return { ...file, fileName: normalFilePath };
  }
  updateInternalLinks(linkMap, newPath) {
    const changes = LinkToChanges(linkMap, newPath);
    this.app.fileManager.updateInternalLinks(changes);
  }
  renameCanvasSubpath(origin, newFile) {
    var _a, _b;
    const canvasUpdater = this.app.fileManager.linkUpdaters.canvas;
    if (origin.file.path === newFile.file.path && origin.subpath !== newFile.subpath) {
      canvasUpdater.renameSubpath(origin.file, (_a = origin.subpath) != null ? _a : "", (_b = newFile.subpath) != null ? _b : "");
    }
  }
  getCanvas(filter) {
    const canvasUpdater = this.app.fileManager.linkUpdaters.canvas;
    const canvases = canvasUpdater.canvas.index.getAll();
    const queue = [];
    for (const canvasFilePath in canvases) {
      const canvasCache = canvases[canvasFilePath];
      const find = canvasCache.embeds.find((embed) => {
        var _a;
        return (_a = filter == null ? void 0 : filter(canvasFilePath, embed)) != null ? _a : true;
      });
      if (find) {
        queue.push(canvasFilePath);
      }
    }
    return queue;
  }
  updateCanvasNodes(canvasPath, newNode) {
    const canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
    if (canvasFile instanceof import_obsidian15.TFile && canvasFile.extension === "canvas") {
      return this.app.vault.process(canvasFile, (data) => {
        const canvasData = JSON.parse(data);
        const nodeUpdate = canvasData.nodes.map(newNode);
        const newData = {
          edges: canvasData.edges,
          nodes: nodeUpdate
        };
        return JSON.stringify(newData);
      });
    }
  }
  updateCanvasLinks(canvasPathSet, map) {
    const result = canvasPathSet.map((canvasPath) => this.updateCanvasNodes(canvasPath, (node) => {
      if (node.type === "file") {
        return map(node);
      }
      return node;
    }));
    return Promise.all(result);
  }
  findLinkBlocks(file, from, to) {
    var _a, _b;
    const cache = this.app.metadataCache.getFileCache(file);
    const blocks = cache == null ? void 0 : cache.blocks;
    const inRange = (item) => {
      const end = item.position.end;
      return end.offset > from && end.offset <= to;
    };
    const blocksInRange = [];
    for (const blockName in blocks) {
      const blockInfo = blocks[blockName];
      if (inRange(blockInfo)) {
        blocksInRange.push(blockInfo);
      }
    }
    const headingInRange = (_b = (_a = cache == null ? void 0 : cache.headings) == null ? void 0 : _a.filter(inRange)) != null ? _b : [];
    return [blocksInRange, headingInRange];
  }
  createLinkInfo(cache) {
    const normalizeLink = cache.link.replace(/\u00A0/, "").normalize();
    const path = normalizeLink.split("#")[0];
    const subpath = normalizeLink.substring(path.length);
    return {
      path,
      subpath,
      link: cache
    };
  }
  findLinks(targetFile, match) {
    return new Promise((res) => {
      const cache = this.app.metadataCache;
      const fileManger = this.app.fileManager;
      const linkMap = /* @__PURE__ */ new Map();
      fileManger.iterateAllRefs((fileName, linkCache) => {
        var _a;
        fileName.normalize();
        const linkInfo = this.createLinkInfo(linkCache);
        const { path, subpath } = linkInfo;
        if (match({ path, subpath, file: (_a = cache.getFirstLinkpathDest(path, fileName)) != null ? _a : void 0 })) {
          const links = linkMap.get(fileName);
          if (links) {
            links.push(linkInfo);
          } else {
            linkMap.set(fileName, [linkInfo]);
          }
        }
      });
      const selfLink = linkMap.get(targetFile.path);
      linkMap.delete(targetFile.path);
      res([selfLink, linkMap]);
    });
  }
  normalizeHeadingToLinkText(heading) {
    const path = heading.replace(HEADINGREPLACE(), " ").replace(/\s+/g, " ");
    return path;
  }
  replaceSpaceInLinkText(link) {
    const useMarkdownLink = this.app.vault.getConfig("useMarkdownLinks");
    return useMarkdownLink ? link.replace(" ", "%20") : link;
  }
  createRandomHexString(length = 6) {
    const id = [...Array(length).keys()].map((_) => (16 * Math.random() | 0).toString(16)).join("");
    return id;
  }
  listenDragAndDrop(e, content, dropEvent) {
    const trim = content.trim(), display = trim.length > 600 ? trim.substring(0, 600).concat(" ...") : trim;
    const floatingSplits = this.app.workspace.floatingSplit, popoutWindows = floatingSplits.children.map((win) => win.containerEl), allWindows = [this.app.workspace.containerEl].concat(popoutWindows), eventListeners = allWindows.map((container) => this.createDraggingAndDropEvent(e, container, display, dropEvent));
    return {
      reset: () => eventListeners.forEach((listen2) => listen2.reset())
    };
  }
  createDraggingAndDropEvent(e, container, content, dropEvent) {
    const dragContentEle = document.createElement("div");
    dragContentEle.hide();
    dragContentEle.style.transform = `translate(${e.clientX}px,${e.clientY}px)`;
    dragContentEle.style.width = "300px";
    dragContentEle.style.height = "min-content";
    dragContentEle.style.position = "absolute";
    dragContentEle.style.padding = "5px 25px";
    dragContentEle.style.borderWidth = "3px";
    dragContentEle.style.borderRadius = "10px";
    dragContentEle.style.border = "solid";
    dragContentEle.style.pointerEvents = "none";
    const dragoverBackground = document.createElement("div");
    dragoverBackground.setCssStyles({
      opacity: "0",
      width: "100%",
      height: "100%",
      position: "fixed"
    });
    import_obsidian15.MarkdownRenderer.render(
      this.app,
      content,
      dragContentEle,
      "",
      this
    );
    container.appendChild(dragoverBackground);
    container.appendChild(dragContentEle);
    const showDragContent = (e2) => {
      dragContentEle.show();
    };
    const moveDragContent = (e2) => {
      const x = e2.clientX, y = e2.clientY;
      dragContentEle.style.transform = `translate(${x}px,${y}px)`;
      e2.preventDefault();
    };
    const hideDragContent = (e2) => {
      if (e2.target === dragoverBackground) {
        dragContentEle.hide();
      }
    };
    container.addEventListener("dragenter", showDragContent);
    container.addEventListener("dragover", moveDragContent);
    container.addEventListener("dragleave", hideDragContent);
    container.addEventListener("drop", dropEvent);
    return {
      reset: () => {
        container.removeChild(dragContentEle);
        container.removeChild(dragoverBackground);
        container.removeEventListener("drop", dropEvent);
        container.removeEventListener("dragover", moveDragContent);
        container.removeEventListener("dragenter", showDragContent);
        container.removeEventListener("dragleave", hideDragContent);
      }
    };
  }
  getDropView(e) {
    const locate = this.app.workspace.getDropLocation(e), target = locate.children.find((child) => child.tabHeaderEl.className.contains("active")), drawView = target == null ? void 0 : target.view;
    return drawView;
  }
  onClickOpenFile(e, file, openState) {
    const isFnKey = () => e.ctrlKey || e.metaKey;
    this.app.workspace.getLeaf(
      isFnKey() && e.shiftKey && e.altKey ? "window" : isFnKey() && e.altKey ? "split" : isFnKey() ? "tab" : false
    ).openFile(file, openState);
  }
  arrowToFrom() {
    return this.settings.arrowTo == "both" || this.settings.arrowTo == "from";
  }
  arrowToEnd() {
    return this.settings.arrowTo == "both" || this.settings.arrowTo == "end";
  }
};
var CardNoteTab = class extends import_obsidian15.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian15.Setting(containerEl).setName("Drag symbol").setDesc("You can set your prefer drag symbol here").addText(
      (text2) => text2.setPlaceholder("Enter your drag symbol here").setValue(this.plugin.settings.dragSymbol).onChange(async (value) => {
        this.plugin.settings.dragSymbol = value;
        await this.plugin.saveSettings();
      })
    );
    this.addSizeSetting();
    new import_obsidian15.Setting(containerEl).setName("Default folder").setDesc("Default loction for new note. if empty, new note will be created in the vault root.").addText(
      (text2) => text2.setPlaceholder("/sub folder name").setValue(this.plugin.settings.defaultFolder).onChange(async (value) => {
        this.plugin.settings.defaultFolder = value;
        await this.plugin.saveSettings();
      })
    );
  }
  addSizeSetting() {
    const desc = (value) => {
      return `Change your symbol size. Current size is ${value != null ? value : this.plugin.settings.dragSymbolSize}.(min=1 max=100)`;
    };
    const sizeSetting = new import_obsidian15.Setting(this.containerEl).setName("Symbol size (px)").setDesc(desc()).addSlider(
      (slider) => {
        var _a;
        slider.setLimits(1, 100, 1).setValue((_a = this.plugin.settings.dragSymbolSize) != null ? _a : 18).onChange(async (value) => {
          sizeSetting.setDesc(desc(value));
          this.plugin.settings.dragSymbolSize = value;
          await this.plugin.saveSettings();
        }).setDynamicTooltip();
      }
    );
  }
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
